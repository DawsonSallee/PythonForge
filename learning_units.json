[
  {
    "unit_id": "interpreter.rst-0",
    "source_file": "interpreter.rst",
    "topic_hierarchy": [
      "Invoking the Interpreter",
      "Interactive Mode"
    ],
    "concept_text": "When commands are read from a tty, the interpreter is said to be in *interactive\nmode*.  In this mode it prompts for the next command with the *primary prompt*,\nusually three greater-than signs (``>>>``); for continuation lines it prompts\nwith the *secondary prompt*, by default three dots (``...``). The interpreter\nprints a welcome message stating its version number and a copyright notice\nbefore printing the first prompt:\n\n\n$ python3.15\nPython 3.15 (default, May 7 2025, 15:46:04)\n[GCC 10.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n\n\nContinuation lines are needed when entering a multi-line construct. As an",
    "example_code": "the_world_is_flat = True\n\nif the_world_is_flat:\n\n    print(\"Be careful not to fall off!\")\n\n...\n\nBe careful not to fall off!"
  },
  {
    "unit_id": "interpreter.rst-1",
    "source_file": "interpreter.rst",
    "topic_hierarchy": [
      "The Interpreter and Its Environment",
      "Source Code Encoding"
    ],
    "concept_text": "By default, Python source files are treated as encoded in UTF-8.  In that\nencoding, characters of most languages in the world can be used simultaneously\nin string literals, identifiers and comments --- although the standard library\nonly uses ASCII characters for identifiers, a convention that any portable code\nshould follow.  To display all these characters properly, your editor must\nrecognize that the file is UTF-8, and it must use a font that supports all the\ncharacters in the file.\n\nTo declare an encoding other than the default one, a special comment line",
    "example_code": ""
  },
  {
    "unit_id": "interpreter.rst-2",
    "source_file": "interpreter.rst",
    "topic_hierarchy": [
      "The Interpreter and Its Environment",
      "Source Code Encoding"
    ],
    "concept_text": "where *encoding* is one of the valid :mod:`codecs` supported by Python.\n\nFor example, to declare that Windows-1252 encoding is to be used, the first",
    "example_code": ""
  },
  {
    "unit_id": "interpreter.rst-3",
    "source_file": "interpreter.rst",
    "topic_hierarchy": [
      "The Interpreter and Its Environment",
      "Source Code Encoding"
    ],
    "concept_text": "One exception to the *first line* rule is when the source code starts with a\n:ref:`UNIX \"shebang\" line <tut-scripts>`.  In this case, the encoding",
    "example_code": ""
  },
  {
    "unit_id": "introduction.rst-0",
    "source_file": "introduction.rst",
    "topic_hierarchy": [],
    "concept_text": "**********************************\nAn Informal Introduction to Python\n**********************************\n\nIn the following examples, input and output are distinguished by the presence or\nabsence of prompts (:term:`>>>` and :term:`...`): to repeat the example, you must type\neverything after the prompt, when the prompt appears; lines that do not begin\nwith a prompt are output from the interpreter. Note that a secondary prompt on a\nline by itself in an example means you must type a blank line; this is used to\nend a multi-line command.\n\n\nYou can use the \"Copy\" button (it appears in the upper-right corner\nwhen hovering over or tapping a code example), which strips prompts\nand omits output, to copy and paste the input lines into your interpreter.\n\n\nMany of the examples in this manual, even those entered at the interactive\nprompt, include comments.  Comments in Python start with the hash character,\n``#``, and extend to the end of the physical line.  A comment may appear at the\nstart of a line or following whitespace or code, but not within a string\nliteral.  A hash character within a string literal is just a hash character.\nSince comments are to clarify code and are not interpreted by Python, they may\nbe omitted when typing in examples.",
    "example_code": "spam = 1  # and this is the second comment\n\ntext = \"# This is not a comment because it's inside quotes.\""
  },
  {
    "unit_id": "introduction.rst-1",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "The interpreter acts as a simple calculator: you can type an expression at it\nand it will write the value.  Expression syntax is straightforward: the\noperators ``+``, ``-``, ``*`` and ``/`` can be used to perform\narithmetic; parentheses (``()``) can be used for grouping.",
    "example_code": "2 + 2\n\n4\n\n50 - 5*6\n\n20\n\n(50 - 5*6) / 4\n\n5.0\n\n8 / 5  # division always returns a floating-point number\n\n1.6"
  },
  {
    "unit_id": "introduction.rst-2",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "The integer numbers (e.g. ``2``, ``4``, ``20``) have type :class:`int`,\nthe ones with a fractional part (e.g. ``5.0``, ``1.6``) have type\n:class:`float`.  We will see more about numeric types later in the tutorial.\n\nDivision (``/``) always returns a float.  To do :term:`floor division` and\nget an integer result you can use the ``//`` operator; to calculate",
    "example_code": "17 / 3  # classic division returns a float\n\n5.666666666666667\n\n>>>\n\n17 // 3  # floor division discards the fractional part\n\n5\n\n17 % 3  # the % operator returns the remainder of the division\n\n2\n\n5 * 3 + 2  # floored quotient * divisor + remainder\n\n17"
  },
  {
    "unit_id": "introduction.rst-3",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "",
    "example_code": "5 ** 2  # 5 squared\n\n25\n\n2 ** 7  # 2 to the power of 7\n\n128"
  },
  {
    "unit_id": "introduction.rst-4",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "The equal sign (``=``) is used to assign a value to a variable. Afterwards, no",
    "example_code": "width = 20\n\nheight = 5 * 9\n\nwidth * height\n\n900"
  },
  {
    "unit_id": "introduction.rst-5",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "If a variable is not \"defined\" (assigned a value), trying to use it will",
    "example_code": "n  # try to access an undefined variable\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nNameError: name 'n' is not defined"
  },
  {
    "unit_id": "introduction.rst-6",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "There is full support for floating point; operators with mixed type operands",
    "example_code": "4 * 3.75 - 1\n\n14.0"
  },
  {
    "unit_id": "introduction.rst-7",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Numbers"
    ],
    "concept_text": "In interactive mode, the last printed expression is assigned to the variable\n``_``.  This means that when you are using Python as a desk calculator, it is",
    "example_code": "tax = 12.5 / 100\n\nprice = 100.50\n\nprice * tax\n\n12.5625\n\nprice + _\n\n113.0625\n\nround(_, 2)\n\n113.06"
  },
  {
    "unit_id": "introduction.rst-8",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Python can manipulate text (represented by type :class:`str`, so-called\n\"strings\") as well as numbers.  This includes characters \"``!``\", words\n\"``rabbit``\", names \"``Paris``\", sentences \"``Got your back.``\", etc.\n\"``Yay! :)``\". They can be enclosed in single quotes (``'...'``) or double\nquotes (``\"...\"``) with the same result [#]_.\n\n\n>>> 'spam eggs'  # single quotes\n'spam eggs'\n>>> \"Paris rabbit got your back :)! Yay!\"  # double quotes\n'Paris rabbit got your back :)! Yay!'\n>>> '1975'  # digits and numerals enclosed in quotes are also strings\n'1975'\n\nTo quote a quote, we need to \"escape\" it, by preceding it with ``\\``.",
    "example_code": "'doesn\\'t'  # use \\' to escape the single quote...\n\n\"doesn't\"\n\n\"doesn't\"  # ...or use double quotes instead\n\n\"doesn't\"\n\n'\"Yes,\" they said.'\n\n'\"Yes,\" they said.'\n\n\"\\\"Yes,\\\" they said.\"\n\n'\"Yes,\" they said.'\n\n'\"Isn\\'t,\" they said.'\n\n'\"Isn\\'t,\" they said.'"
  },
  {
    "unit_id": "introduction.rst-9",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "In the Python shell, the string definition and output string can look\ndifferent.  The :func:`print` function produces a more readable output, by",
    "example_code": "s = 'First line.\\nSecond line.'  # \\n means newline\n\ns  # without print(), special characters are included in the string\n\n'First line.\\nSecond line.'\n\nprint(s)  # with print(), special characters are interpreted, so \\n produces new line\n\nFirst line.\n\nSecond line."
  },
  {
    "unit_id": "introduction.rst-10",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "If you don't want characters prefaced by ``\\`` to be interpreted as\nspecial characters, you can use *raw strings* by adding an ``r`` before",
    "example_code": "print('C:\\some\\name')  # here \\n means newline!\n\nC:\\some\n\name\n\nprint(r'C:\\some\\name')  # note the r before the quote\n\nC:\\some\\name"
  },
  {
    "unit_id": "introduction.rst-11",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "There is one subtle aspect to raw strings: a raw string may not end in\nan odd number of ``\\`` characters; see\n:ref:`the FAQ entry <faq-programming-raw-string-backslash>` for more information\nand workarounds.\n\nString literals can span multiple lines.  One way is using triple-quotes:\n``\"\"\"...\"\"\"`` or ``'''...'''``.  End-of-line characters are automatically\nincluded in the string, but it's possible to prevent this by adding a ``\\`` at\nthe end of the line.  In the following example, the initial newline is not",
    "example_code": "print(\"\"\"\\\n\nUsage: thingy [OPTIONS]\n\n     -h                        Display this usage message\n\n     -H hostname               Hostname to connect to\n\n\"\"\")\n\nUsage: thingy [OPTIONS]\n\n     -h                        Display this usage message\n\n     -H hostname               Hostname to connect to\n\n\n>>>"
  },
  {
    "unit_id": "introduction.rst-12",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Strings can be concatenated (glued together) with the ``+`` operator, and",
    "example_code": "3 * 'un' + 'ium'\n\n'unununium'"
  },
  {
    "unit_id": "introduction.rst-13",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Two or more *string literals* (i.e. the ones enclosed between quotes) next",
    "example_code": "'Py' 'thon'\n\n'Python'"
  },
  {
    "unit_id": "introduction.rst-14",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "text = ('Put several strings within parentheses '\n\n        'to have them joined together.')\n\ntext\n\n'Put several strings within parentheses to have them joined together.'"
  },
  {
    "unit_id": "introduction.rst-15",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "prefix = 'Py'\n\nprefix 'thon'  # can't concatenate a variable and a string literal\n\n  File \"<stdin>\", line 1\n\n    prefix 'thon'\n\n           ^^^^^^\n\nSyntaxError: invalid syntax\n\n('un' * 3) 'ium'\n\n  File \"<stdin>\", line 1\n\n    ('un' * 3) 'ium'\n\n               ^^^^^\n\nSyntaxError: invalid syntax"
  },
  {
    "unit_id": "introduction.rst-16",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "prefix + 'thon'\n\n'Python'"
  },
  {
    "unit_id": "introduction.rst-17",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Strings can be *indexed* (subscripted), with the first character having index 0.\nThere is no separate character type; a character is simply a string of size",
    "example_code": "word = 'Python'\n\nword[0]  # character in position 0\n\n'P'\n\nword[5]  # character in position 5\n\n'n'"
  },
  {
    "unit_id": "introduction.rst-18",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "word[-1]  # last character\n\n'n'\n\nword[-2]  # second-last character\n\n'o'\n\nword[-6]\n\n'P'"
  },
  {
    "unit_id": "introduction.rst-19",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Note that since -0 is the same as 0, negative indices start from -1.\n\nIn addition to indexing, *slicing* is also supported.  While indexing is used",
    "example_code": "word[0:2]  # characters from position 0 (included) to 2 (excluded)\n\n'Py'\n\nword[2:5]  # characters from position 2 (included) to 5 (excluded)\n\n'tho'"
  },
  {
    "unit_id": "introduction.rst-20",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Slice indices have useful defaults; an omitted first index defaults to zero, an",
    "example_code": "word[:2]   # character from the beginning to position 2 (excluded)\n\n'Py'\n\nword[4:]   # characters from position 4 (included) to the end\n\n'on'\n\nword[-2:]  # characters from the second-last (included) to the end\n\n'on'"
  },
  {
    "unit_id": "introduction.rst-21",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Note how the start is always included, and the end always excluded.  This",
    "example_code": "word[:2] + word[2:]\n\n'Python'\n\nword[:4] + word[4:]\n\n'Python'"
  },
  {
    "unit_id": "introduction.rst-22",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "One way to remember how slices work is to think of the indices as pointing\n*between* characters, with the left edge of the first character numbered 0.\nThen the right edge of the last character of a string of *n* characters has",
    "example_code": "+---+---+---+---+---+---+\n\n| P | y | t | h | o | n |\n\n+---+---+---+---+---+---+\n\n0   1   2   3   4   5   6"
  },
  {
    "unit_id": "introduction.rst-23",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "-6  -5  -4  -3  -2  -1\n\nThe first row of numbers gives the position of the indices 0...6 in the string;\nthe second row gives the corresponding negative indices. The slice from *i* to\n*j* consists of all characters between the edges labeled *i* and *j*,\nrespectively.\n\nFor non-negative indices, the length of a slice is the difference of the\nindices, if both are within bounds.  For example, the length of ``word[1:3]`` is\n2.",
    "example_code": "word[42]  # the word only has 6 characters\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nIndexError: string index out of range"
  },
  {
    "unit_id": "introduction.rst-24",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "However, out of range slice indexes are handled gracefully when used for",
    "example_code": "word[4:42]\n\n'on'\n\nword[42:]\n\n''"
  },
  {
    "unit_id": "introduction.rst-25",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "Python strings cannot be changed --- they are :term:`immutable`.",
    "example_code": "word[0] = 'J'\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'str' object does not support item assignment\n\nword[2:] = 'py'\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "unit_id": "introduction.rst-26",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "'J' + word[1:]\n\n'Jython'\n\nword[:2] + 'py'\n\n'Pypy'"
  },
  {
    "unit_id": "introduction.rst-27",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": "s = 'supercalifragilisticexpialidocious'\n\nlen(s)\n\n34"
  },
  {
    "unit_id": "introduction.rst-28",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Text"
    ],
    "concept_text": "",
    "example_code": ":ref:`textseq`\n\n   Strings are examples of *sequence types*, and support the common\n\n   operations supported by such types.\n\n\n:ref:`string-methods`\n\n   Strings support a large number of methods for\n\n   basic transformations and searching.\n\n\n:ref:`f-strings`\n\n   String literals that have embedded expressions.\n\n\n:ref:`formatstrings`\n\n   Information about string formatting with :meth:`str.format`.\n\n\n:ref:`old-string-formatting`\n\n   The old formatting operations invoked when strings are\n\n   the left operand of the ``%`` operator are described in more detail here."
  },
  {
    "unit_id": "introduction.rst-29",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "Python knows a number of *compound* data types, used to group together other\nvalues.  The most versatile is the *list*, which can be written as a list of\ncomma-separated values (items) between square brackets.  Lists might contain",
    "example_code": "squares = [1, 4, 9, 16, 25]\n\nsquares\n\n[1, 4, 9, 16, 25]"
  },
  {
    "unit_id": "introduction.rst-30",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "Like strings (and all other built-in :term:`sequence` types), lists can be",
    "example_code": "squares[0]  # indexing returns the item\n\n1\n\nsquares[-1]\n\n25\n\nsquares[-3:]  # slicing returns a new list\n\n[9, 16, 25]"
  },
  {
    "unit_id": "introduction.rst-31",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "",
    "example_code": "squares + [36, 49, 64, 81, 100]\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"
  },
  {
    "unit_id": "introduction.rst-32",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "Unlike strings, which are :term:`immutable`, lists are a :term:`mutable`",
    "example_code": "cubes = [1, 8, 27, 65, 125]  # something's wrong here\n\n4 ** 3  # the cube of 4 is 64, not 65!\n\n64\n\ncubes[3] = 64  # replace the wrong value\n\ncubes\n\n[1, 8, 27, 64, 125]"
  },
  {
    "unit_id": "introduction.rst-33",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "You can also add new items at the end of the list, by using",
    "example_code": "cubes.append(216)  # add the cube of 6\n\ncubes.append(7 ** 3)  # and the cube of 7\n\ncubes\n\n[1, 8, 27, 64, 125, 216, 343]"
  },
  {
    "unit_id": "introduction.rst-34",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "Simple assignment in Python never copies data. When you assign a list\nto a variable, the variable refers to the *existing list*.\nAny changes you make to the list through one variable will be seen",
    "example_code": "rgb = [\"Red\", \"Green\", \"Blue\"]\n\nrgba = rgb\n\nid(rgb) == id(rgba)  # they reference the same object\n\nTrue\n\nrgba.append(\"Alph\")\n\nrgb\n\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]"
  },
  {
    "unit_id": "introduction.rst-35",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "All slice operations return a new list containing the requested elements.  This\nmeans that the following slice returns a",
    "example_code": "correct_rgba = rgba[:]\n\ncorrect_rgba[-1] = \"Alpha\"\n\ncorrect_rgba\n\n[\"Red\", \"Green\", \"Blue\", \"Alpha\"]\n\nrgba\n\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]"
  },
  {
    "unit_id": "introduction.rst-36",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "Assignment to slices is also possible, and this can even change the size of the",
    "example_code": "letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\nletters\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\nletters[2:5] = ['C', 'D', 'E']\n\nletters\n\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n\nletters[2:5] = []\n\nletters\n\n['a', 'b', 'f', 'g']\n\nletters[:] = []\n\nletters\n\n[]"
  },
  {
    "unit_id": "introduction.rst-37",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "",
    "example_code": "letters = ['a', 'b', 'c', 'd']\n\nlen(letters)\n\n4"
  },
  {
    "unit_id": "introduction.rst-38",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "Using Python as a Calculator",
      "Lists"
    ],
    "concept_text": "It is possible to nest lists (create lists containing other lists), for",
    "example_code": "a = ['a', 'b', 'c']\n\nn = [1, 2, 3]\n\nx = [a, n]\n\nx\n\n[['a', 'b', 'c'], [1, 2, 3]]\n\nx[0]\n\n['a', 'b', 'c']\n\nx[0][1]\n\n'b'"
  },
  {
    "unit_id": "introduction.rst-39",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "First Steps Towards Programming"
    ],
    "concept_text": "Of course, we can use Python for more complicated tasks than adding two and two\ntogether.  For instance, we can write an initial sub-sequence of the\n`Fibonacci series <https://en.wikipedia.org/wiki/Fibonacci_sequence>`_",
    "example_code": "a, b = 0, 1\n\nwhile a < 10:\n\n    print(a)\n\n    a, b = b, a+b\n\n...\n\n0\n\n1\n\n1\n\n2\n\n3\n\n5\n\n8"
  },
  {
    "unit_id": "introduction.rst-40",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "First Steps Towards Programming"
    ],
    "concept_text": "This example introduces several new features.\n\n* The first line contains a *multiple assignment*: the variables ``a`` and ``b``\nsimultaneously get the new values 0 and 1.  On the last line this is used again,\ndemonstrating that the expressions on the right-hand side are all evaluated\nfirst before any of the assignments take place.  The right-hand side expressions\nare evaluated  from the left to the right.\n\n* The :keyword:`while` loop executes as long as the condition (here: ``a < 10``)\nremains true.  In Python, like in C, any non-zero integer value is true; zero is\nfalse.  The condition may also be a string or list value, in fact any sequence;\nanything with a non-zero length is true, empty sequences are false.  The test\nused in the example is a simple comparison.  The standard comparison operators\nare written the same as in C: ``<`` (less than), ``>`` (greater than), ``==``\n(equal to), ``<=`` (less than or equal to), ``>=`` (greater than or equal to)\nand ``!=`` (not equal to).\n\n* The *body* of the loop is *indented*: indentation is Python's way of grouping\nstatements.  At the interactive prompt, you have to type a tab or space(s) for\neach indented line.  In practice you will prepare more complicated input\nfor Python with a text editor; all decent text editors have an auto-indent\nfacility.  When a compound statement is entered interactively, it must be\nfollowed by a blank line to indicate completion (since the parser cannot\nguess when you have typed the last line).  Note that each line within a basic\nblock must be indented by the same amount.\n\n* The :func:`print` function writes the value of the argument(s) it is given.\nIt differs from just writing the expression you want to write (as we did\nearlier in the calculator examples) in the way it handles multiple arguments,\nfloating-point quantities, and strings.  Strings are printed without quotes,\nand a space is inserted between items, so you can format things nicely, like",
    "example_code": "i = 256*256\n\nprint('The value of i is', i)\n\nThe value of i is 65536"
  },
  {
    "unit_id": "introduction.rst-41",
    "source_file": "introduction.rst",
    "topic_hierarchy": [
      "First Steps Towards Programming"
    ],
    "concept_text": "The keyword argument *end* can be used to avoid the newline after the output,",
    "example_code": "a, b = 0, 1\n\nwhile a < 1000:\n\n    print(a, end=',')\n\n    a, b = b, a+b\n\n...\n\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,"
  },
  {
    "unit_id": "controlflow.rst-0",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!if` Statements"
    ],
    "concept_text": "Perhaps the most well-known statement type is the :keyword:`if` statement.  For",
    "example_code": "x = int(input(\"Please enter an integer: \"))\n\nPlease enter an integer: 42\n\nif x < 0:\n\n    x = 0\n\n    print('Negative changed to zero')\n\nelif x == 0:\n\n    print('Zero')\n\nelif x == 1:\n\n    print('Single')\n\nelse:\n\n    print('More')\n\n...\n\nMore"
  },
  {
    "unit_id": "controlflow.rst-1",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!for` Statements"
    ],
    "concept_text": "",
    "example_code": "pair: statement; for"
  },
  {
    "unit_id": "controlflow.rst-2",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!for` Statements"
    ],
    "concept_text": "The :keyword:`for` statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Python's :keyword:`!for` statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n\nconfuse non-C programmers.",
    "example_code": "words = ['cat', 'window', 'defenestrate']\n\nfor w in words:\n\n    print(w, len(w))\n\n...\n\ncat 3\n\nwindow 6\n\ndefenestrate 12"
  },
  {
    "unit_id": "controlflow.rst-3",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!for` Statements"
    ],
    "concept_text": "Code that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop",
    "example_code": "users = {'Hans': 'active', '\u00c9l\u00e9onore': 'inactive', '\u666f\u592a\u90ce': 'active'}\n\n\nfor user, status in users.copy().items():\n\n    if status == 'inactive':\n\n        del users[user]\n\n\nactive_users = {}\n\nfor user, status in users.items():\n\n    if status == 'active':\n\n        active_users[user] = status"
  },
  {
    "unit_id": "controlflow.rst-4",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "The :func:`range` Function"
    ],
    "concept_text": "If you do need to iterate over a sequence of numbers, the built-in function",
    "example_code": "for i in range(5):\n\n    print(i)\n\n...\n\n0\n\n1\n\n2\n\n3\n\n4"
  },
  {
    "unit_id": "controlflow.rst-5",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "The :func:`range` Function"
    ],
    "concept_text": "The given end point is never part of the generated sequence; ``range(10)`` generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different",
    "example_code": "list(range(5, 10))\n\n[5, 6, 7, 8, 9]\n\n\nlist(range(0, 10, 3))\n\n[0, 3, 6, 9]\n\n\nlist(range(-10, -100, -30))\n\n[-10, -40, -70]"
  },
  {
    "unit_id": "controlflow.rst-6",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "The :func:`range` Function"
    ],
    "concept_text": "To iterate over the indices of a sequence, you can combine :func:`range` and",
    "example_code": "a = ['Mary', 'had', 'a', 'little', 'lamb']\n\nfor i in range(len(a)):\n\n    print(i, a[i])\n\n...\n\n0 Mary\n\n1 had\n\n2 a\n\n3 little\n\n4 lamb"
  },
  {
    "unit_id": "controlflow.rst-7",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "The :func:`range` Function"
    ],
    "concept_text": "In most such cases, however, it is convenient to use the :func:`enumerate`\nfunction, see :ref:`tut-loopidioms`.",
    "example_code": "range(10)\n\nrange(0, 10)"
  },
  {
    "unit_id": "controlflow.rst-8",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "The :func:`range` Function"
    ],
    "concept_text": "In many ways the object returned by :func:`range` behaves as if it is a list,\nbut in fact it isn't. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesn't really make\nthe list, thus saving space.\n\nWe say such an object is :term:`iterable`, that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe :keyword:`for` statement is such a construct, while an example of a function",
    "example_code": "sum(range(4))  # 0 + 1 + 2 + 3\n\n6"
  },
  {
    "unit_id": "controlflow.rst-9",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!break` and :keyword:`!continue` Statements"
    ],
    "concept_text": "The :keyword:`break` statement breaks out of the innermost enclosing",
    "example_code": "for n in range(2, 10):\n\n    for x in range(2, n):\n\n        if n % x == 0:\n\n            print(f\"{n} equals {x} * {n//x}\")\n\n            break\n\n...\n\n4 equals 2 * 2\n\n6 equals 2 * 3\n\n8 equals 2 * 4\n\n9 equals 3 * 3"
  },
  {
    "unit_id": "controlflow.rst-10",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!break` and :keyword:`!continue` Statements"
    ],
    "concept_text": "The :keyword:`continue` statement continues with the next",
    "example_code": "for num in range(2, 10):\n\n    if num % 2 == 0:\n\n        print(f\"Found an even number {num}\")\n\n        continue\n\n    print(f\"Found an odd number {num}\")\n\n...\n\nFound an even number 2\n\nFound an odd number 3\n\nFound an even number 4\n\nFound an odd number 5\n\nFound an even number 6\n\nFound an odd number 7\n\nFound an even number 8\n\nFound an odd number 9"
  },
  {
    "unit_id": "controlflow.rst-11",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!else` Clauses on Loops"
    ],
    "concept_text": "In a :keyword:`!for` or :keyword:`!while` loop the :keyword:`!break` statement\nmay be paired with an :keyword:`!else` clause.  If the loop finishes without\nexecuting the :keyword:`!break`, the :keyword:`!else` clause executes.\n\nIn a :keyword:`for` loop, the :keyword:`!else` clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\n\nIn a :keyword:`while` loop, it's executed after the loop's condition becomes false.\n\nIn either kind of loop, the :keyword:`!else` clause is **not** executed if the\nloop was terminated by a :keyword:`break`.  Of course, other ways of ending the\nloop early, such as a :keyword:`return` or a raised exception, will also skip\nexecution of the :keyword:`else` clause.\n\nThis is exemplified in the following :keyword:`!for` loop,",
    "example_code": "for n in range(2, 10):\n\n    for x in range(2, n):\n\n        if n % x == 0:\n\n            print(n, 'equals', x, '*', n//x)\n\n            break\n\n    else:\n\n        print(n, 'is a prime number')\n\n...\n\n2 is a prime number\n\n3 is a prime number\n\n4 equals 2 * 2\n\n5 is a prime number\n\n6 equals 2 * 3\n\n7 is a prime number\n\n8 equals 2 * 4\n\n9 equals 3 * 3"
  },
  {
    "unit_id": "controlflow.rst-12",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!pass` Statements"
    ],
    "concept_text": "The :keyword:`pass` statement does nothing. It can be used when a statement is",
    "example_code": "while True:\n\n    pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n\n..."
  },
  {
    "unit_id": "controlflow.rst-13",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!pass` Statements"
    ],
    "concept_text": "",
    "example_code": "class MyEmptyClass:\n\n    pass\n\n..."
  },
  {
    "unit_id": "controlflow.rst-14",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!pass` Statements"
    ],
    "concept_text": "Another place :keyword:`pass` can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking",
    "example_code": "def initlog(*args):\n\n    pass   # Remember to implement this!\n\n..."
  },
  {
    "unit_id": "controlflow.rst-15",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "A :keyword:`match` statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but it's more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables. If no case matches,\nnone of the branches is executed.",
    "example_code": "def http_error(status):\n\n    match status:\n\n        case 400:\n\n            return \"Bad request\"\n\n        case 404:\n\n            return \"Not found\"\n\n        case 418:\n\n            return \"I'm a teapot\"\n\n        case _:\n\n            return \"Something's wrong with the internet\""
  },
  {
    "unit_id": "controlflow.rst-16",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and\nnever fails to match.",
    "example_code": "case 401 | 403 | 404:\n\n    return \"Not allowed\""
  },
  {
    "unit_id": "controlflow.rst-17",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "Patterns can look like unpacking assignments, and can be used to bind",
    "example_code": "match point:\n\n    case (0, 0):\n\n        print(\"Origin\")\n\n    case (0, y):\n\n        print(f\"Y={y}\")\n\n    case (x, 0):\n\n        print(f\"X={x}\")\n\n    case (x, y):\n\n        print(f\"X={x}, Y={y}\")\n\n    case _:\n\n        raise ValueError(\"Not a point\")"
  },
  {
    "unit_id": "controlflow.rst-18",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "Study that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable *binds* a value from the subject (``point``).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment ``(x, y) = point``.\n\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a",
    "example_code": "class Point:\n\n    def __init__(self, x, y):\n\n        self.x = x\n\n        self.y = y\n\n\ndef where_is(point):\n\n    match point:\n\n        case Point(x=0, y=0):\n\n            print(\"Origin\")\n\n        case Point(x=0, y=y):\n\n            print(f\"Y={y}\")\n\n        case Point(x=x, y=0):\n\n            print(f\"X={x}\")\n\n        case Point():\n\n            print(\"Somewhere else\")\n\n        case _:\n\n            print(\"Not a point\")"
  },
  {
    "unit_id": "controlflow.rst-19",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "You can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the ``__match_args__`` special\nattribute in your classes. If it's set to (\"x\", \"y\"), the following patterns are all",
    "example_code": "Point(1, var)\n\nPoint(1, y=var)\n\nPoint(x=1, y=var)\n\nPoint(y=var, x=1)"
  },
  {
    "unit_id": "controlflow.rst-20",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "A recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like ``var`` above) are assigned to by a match statement.\nDotted names (like ``foo.bar``), attribute names (the ``x=`` and ``y=`` above) or class names\n(recognized by the \"(...)\" next to them like ``Point`` above) are never assigned to.\n\nPatterns can be arbitrarily nested.  For example, if we have a short",
    "example_code": "class Point:\n\n    __match_args__ = ('x', 'y')\n\n    def __init__(self, x, y):\n\n        self.x = x\n\n        self.y = y\n\n\nmatch points:\n\n    case []:\n\n        print(\"No points\")\n\n    case [Point(0, 0)]:\n\n        print(\"The origin\")\n\n    case [Point(x, y)]:\n\n        print(f\"Single point {x}, {y}\")\n\n    case [Point(0, y1), Point(0, y2)]:\n\n        print(f\"Two on the Y axis at {y1}, {y2}\")\n\n    case _:\n\n        print(\"Something else\")"
  },
  {
    "unit_id": "controlflow.rst-21",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "We can add an ``if`` clause to a pattern, known as a \"guard\".  If the\nguard is false, ``match`` goes on to try the next case block.  Note",
    "example_code": "match point:\n\n    case Point(x, y) if x == y:\n\n        print(f\"Y=X at {x}\")\n\n    case Point(x, y):\n\n        print(f\"Not on the diagonal\")"
  },
  {
    "unit_id": "controlflow.rst-22",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "Several other key features of this statement:\n\n- Like unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they don't match iterators or strings.\n\n- Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y,\n*rest)`` work similar to unpacking assignments.  The\nname after ``*`` may also be ``_``, so ``(x, y, *_)`` matches a sequence\nof at least two items without binding the remaining items.\n\n- Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the\n``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like ``**rest`` is also\nsupported.  (But ``**_`` would be redundant, so it is not allowed.)",
    "example_code": "case (Point(x1, y1), Point(x2, y2) as p2): ..."
  },
  {
    "unit_id": "controlflow.rst-23",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      ":keyword:`!match` Statements"
    ],
    "concept_text": "will capture the second element of the input as ``p2`` (as long as the input is\na sequence of two points)\n\n- Most literals are compared by equality, however the singletons ``True``,\n``False`` and ``None`` are compared by identity.\n\n- Patterns may use named constants.  These must be dotted names",
    "example_code": "from enum import Enum\n\nclass Color(Enum):\n\n    RED = 'red'\n\n    GREEN = 'green'\n\n    BLUE = 'blue'\n\n\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n\n\nmatch color:\n\n    case Color.RED:\n\n        print(\"I see red!\")\n\n    case Color.GREEN:\n\n        print(\"Grass is green\")\n\n    case Color.BLUE:\n\n        print(\"I'm feeling the blues :(\")"
  },
  {
    "unit_id": "controlflow.rst-24",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "Defining Functions"
    ],
    "concept_text": "We can create a function that writes the Fibonacci series to an arbitrary",
    "example_code": "def fib(n):    # write Fibonacci series less than n\n\n    \"\"\"Print a Fibonacci series less than n.\"\"\"\n\n    a, b = 0, 1\n\n    while a < n:\n\n        print(a, end=' ')\n\n        a, b = b, a+b\n\n    print()\n\n...\n\nfib(2000)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
  },
  {
    "unit_id": "controlflow.rst-25",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "Defining Functions"
    ],
    "concept_text": "",
    "example_code": "single: documentation strings\n\nsingle: docstrings\n\nsingle: strings, documentation"
  },
  {
    "unit_id": "controlflow.rst-26",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "Defining Functions"
    ],
    "concept_text": "The keyword :keyword:`def` introduces a function *definition*.  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\n\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the function's documentation string, or :dfn:`docstring`.\n(More about docstrings can be found in the section :ref:`tut-docstrings`.)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; it's good\npractice to include docstrings in code that you write, so make a habit of it.\n\nThe *execution* of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a :keyword:`global` statement, or, for variables of enclosing\nfunctions, named in a :keyword:`nonlocal` statement), although they may be\nreferenced.\n\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using *call by value* (where the *value* is always an object *reference*,\nnot the value of the object). [#]_ When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\n\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same",
    "example_code": "fib\n\n<function fib at 10042ed0>\n\nf = fib\n\nf(100)\n\n0 1 1 2 3 5 8 13 21 34 55 89"
  },
  {
    "unit_id": "controlflow.rst-27",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "Defining Functions"
    ],
    "concept_text": "Coming from other languages, you might object that ``fib`` is not a function but\na procedure since it doesn't return a value.  In fact, even functions without a\n:keyword:`return` statement do return a value, albeit a rather boring one.  This\nvalue is called ``None`` (it's a built-in name).  Writing the value ``None`` is\nnormally suppressed by the interpreter if it would be the only value written.",
    "example_code": "fib(0)\n\nprint(fib(0))\n\nNone"
  },
  {
    "unit_id": "controlflow.rst-28",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "Defining Functions"
    ],
    "concept_text": "It is simple to write a function that returns a list of the numbers of the",
    "example_code": "def fib2(n):  # return Fibonacci series up to n\n\n    \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n\n    result = []\n\n    a, b = 0, 1\n\n    while a < n:\n\n        result.append(a)    # see below\n\n        a, b = b, a+b\n\n    return result\n\n...\n\nf100 = fib2(100)    # call it\n\nf100                # write the result\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
  },
  {
    "unit_id": "controlflow.rst-29",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Default Argument Values"
    ],
    "concept_text": "The most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is",
    "example_code": "def ask_ok(prompt, retries=4, reminder='Please try again!'):\n\n    while True:\n\n        reply = input(prompt)\n\n        if reply in {'y', 'ye', 'yes'}:\n\n            return True\n\n        if reply in {'n', 'no', 'nop', 'nope'}:\n\n            return False\n\n        retries = retries - 1\n\n        if retries < 0:\n\n            raise ValueError('invalid user response')\n\n        print(reminder)"
  },
  {
    "unit_id": "controlflow.rst-30",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Default Argument Values"
    ],
    "concept_text": "This function can be called in several ways:\n\n* giving only the mandatory argument:\n``ask_ok('Do you really want to quit?')``\n* giving one of the optional arguments:\n``ask_ok('OK to overwrite the file?', 2)``\n* or even giving all arguments:\n``ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')``\n\nThis example also introduces the :keyword:`in` keyword. This tests whether or\nnot a sequence contains a certain value.\n\nThe default values are evaluated at the point of function definition in the",
    "example_code": "i = 5\n\n\ndef f(arg=i):\n\n    print(arg)\n\n\ni = 6\n\nf()"
  },
  {
    "unit_id": "controlflow.rst-31",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Default Argument Values"
    ],
    "concept_text": "will print ``5``.\n\n**Important warning:**  The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the",
    "example_code": "def f(a, L=[]):\n\n    L.append(a)\n\n    return L\n\n\nprint(f(1))\n\nprint(f(2))\n\nprint(f(3))"
  },
  {
    "unit_id": "controlflow.rst-32",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Default Argument Values"
    ],
    "concept_text": "",
    "example_code": "[1]\n\n[1, 2]\n\n[1, 2, 3]"
  },
  {
    "unit_id": "controlflow.rst-33",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Default Argument Values"
    ],
    "concept_text": "If you don't want the default to be shared between subsequent calls, you can",
    "example_code": "def f(a, L=None):\n\n    if L is None:\n\n        L = []\n\n    L.append(a)\n\n    return L"
  },
  {
    "unit_id": "controlflow.rst-34",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "Functions can also be called using :term:`keyword arguments <keyword argument>`",
    "example_code": "def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n\n    print(\"-- This parrot wouldn't\", action, end=' ')\n\n    print(\"if you put\", voltage, \"volts through it.\")\n\n    print(\"-- Lovely plumage, the\", type)\n\n    print(\"-- It's\", state, \"!\")"
  },
  {
    "unit_id": "controlflow.rst-35",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "accepts one required argument (``voltage``) and three optional arguments\n(``state``, ``action``, and ``type``).  This function can be called in any",
    "example_code": "parrot(1000)                                          # 1 positional argument\n\nparrot(voltage=1000)                                  # 1 keyword argument\n\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\n\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword"
  },
  {
    "unit_id": "controlflow.rst-36",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "",
    "example_code": "parrot()                     # required argument missing\n\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\n\nparrot(110, voltage=220)     # duplicate value for the same argument\n\nparrot(actor='John Cleese')  # unknown keyword argument"
  },
  {
    "unit_id": "controlflow.rst-37",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "In a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. ``actor`` is not a valid argument for the\n``parrot`` function), and their order is not important.  This also includes\nnon-optional arguments (e.g. ``parrot(voltage=1000)`` is valid too).\nNo argument may receive a value more than once.",
    "example_code": "def function(a):\n\n    pass\n\n...\n\nfunction(0, a=0)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: function() got multiple values for argument 'a'"
  },
  {
    "unit_id": "controlflow.rst-38",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "When a final formal parameter of the form ``**name`` is present, it receives a\ndictionary (see :ref:`typesmapping`) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form ``*name`` (described in the next subsection) which\nreceives a :ref:`tuple <tut-tuples>` containing the positional\narguments beyond the formal parameter list.  (``*name`` must occur",
    "example_code": "def cheeseshop(kind, *arguments, **keywords):\n\n    print(\"-- Do you have any\", kind, \"?\")\n\n    print(\"-- I'm sorry, we're all out of\", kind)\n\n    for arg in arguments:\n\n        print(arg)\n\n    print(\"-\" * 40)\n\n    for kw in keywords:\n\n        print(kw, \":\", keywords[kw])"
  },
  {
    "unit_id": "controlflow.rst-39",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Keyword Arguments"
    ],
    "concept_text": "",
    "example_code": "cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\n           \"It's really very, VERY runny, sir.\",\n\n           shopkeeper=\"Michael Palin\",\n\n           client=\"John Cleese\",\n\n           sketch=\"Cheese Shop Sketch\")"
  },
  {
    "unit_id": "controlflow.rst-40",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "Consider the following example function definitions paying close attention to the",
    "example_code": "def standard_arg(arg):\n\n    print(arg)\n\n...\n\ndef pos_only_arg(arg, /):\n\n    print(arg)\n\n...\n\ndef kwd_only_arg(*, arg):\n\n    print(arg)\n\n...\n\ndef combined_example(pos_only, /, standard, *, kwd_only):\n\n    print(pos_only, standard, kwd_only)"
  },
  {
    "unit_id": "controlflow.rst-41",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "The first function definition, ``standard_arg``, the most familiar form,\nplaces no restrictions on the calling convention and arguments may be",
    "example_code": "standard_arg(2)\n\n2\n\n\nstandard_arg(arg=2)\n\n2"
  },
  {
    "unit_id": "controlflow.rst-42",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "The second function ``pos_only_arg`` is restricted to only use positional",
    "example_code": "pos_only_arg(1)\n\n1\n\n\npos_only_arg(arg=1)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'"
  },
  {
    "unit_id": "controlflow.rst-43",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "The third function ``kwd_only_arg`` only allows keyword arguments as indicated",
    "example_code": "kwd_only_arg(3)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n\n\nkwd_only_arg(arg=3)\n\n3"
  },
  {
    "unit_id": "controlflow.rst-44",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "And the last uses all three calling conventions in the same function",
    "example_code": "combined_example(1, 2, 3)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n\n\ncombined_example(1, 2, kwd_only=3)\n\n1 2 3\n\n\ncombined_example(1, standard=2, kwd_only=3)\n\n1 2 3\n\n\ncombined_example(pos_only=1, standard=2, kwd_only=3)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'"
  },
  {
    "unit_id": "controlflow.rst-45",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "",
    "example_code": "def foo(name, **kwds):\n\n    return 'name' in kwds"
  },
  {
    "unit_id": "controlflow.rst-46",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "There is no possible call that will make it return ``True`` as the keyword ``'name'``",
    "example_code": "foo(1, **{'name': 2})\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: foo() got multiple values for argument 'name'\n\n>>>"
  },
  {
    "unit_id": "controlflow.rst-47",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Examples"
    ],
    "concept_text": "",
    "example_code": "def foo(name, /, **kwds):\n\n    return 'name' in kwds\n\n...\n\nfoo(1, **{'name': 2})\n\nTrue"
  },
  {
    "unit_id": "controlflow.rst-48",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Recap"
    ],
    "concept_text": "",
    "example_code": "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"
  },
  {
    "unit_id": "controlflow.rst-49",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Arbitrary Argument Lists"
    ],
    "concept_text": "",
    "example_code": "single: * (asterisk); in function calls"
  },
  {
    "unit_id": "controlflow.rst-50",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Arbitrary Argument Lists"
    ],
    "concept_text": "Finally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see :ref:`tut-tuples`).  Before the variable number of arguments,",
    "example_code": "def write_multiple_items(file, separator, *args):\n\n    file.write(separator.join(args))"
  },
  {
    "unit_id": "controlflow.rst-51",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Arbitrary Argument Lists"
    ],
    "concept_text": "Normally, these *variadic* arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the ``*args``\nparameter are 'keyword-only' arguments, meaning that they can only be used as",
    "example_code": "def concat(*args, sep=\"/\"):\n\n    return sep.join(args)\n\n...\n\nconcat(\"earth\", \"mars\", \"venus\")\n\n'earth/mars/venus'\n\nconcat(\"earth\", \"mars\", \"venus\", sep=\".\")\n\n'earth.mars.venus'"
  },
  {
    "unit_id": "controlflow.rst-52",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Unpacking Argument Lists"
    ],
    "concept_text": "The reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in :func:`range` function expects separate\n*start* and *stop* arguments.  If they are not available separately, write the\nfunction call with the  ``*``\\ -operator to unpack the arguments out of a list",
    "example_code": "list(range(3, 6))            # normal call with separate arguments\n\n[3, 4, 5]\n\nargs = [3, 6]\n\nlist(range(*args))            # call with arguments unpacked from a list\n\n[3, 4, 5]"
  },
  {
    "unit_id": "controlflow.rst-53",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Unpacking Argument Lists"
    ],
    "concept_text": "",
    "example_code": "single: **; in function calls"
  },
  {
    "unit_id": "controlflow.rst-54",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Unpacking Argument Lists"
    ],
    "concept_text": "In the same fashion, dictionaries can deliver keyword arguments with the",
    "example_code": "def parrot(voltage, state='a stiff', action='voom'):\n\n    print(\"-- This parrot wouldn't\", action, end=' ')\n\n    print(\"if you put\", voltage, \"volts through it.\", end=' ')\n\n    print(\"E's\", state, \"!\")\n\n...\n\nd = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n\nparrot(**d)\n\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !"
  },
  {
    "unit_id": "controlflow.rst-55",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Lambda Expressions"
    ],
    "concept_text": "Small anonymous functions can be created with the :keyword:`lambda` keyword.\nThis function returns the sum of its two arguments: ``lambda a, b: a+b``.\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing",
    "example_code": "def make_incrementor(n):\n\n    return lambda x: x + n\n\n...\n\nf = make_incrementor(42)\n\nf(0)\n\n42\n\nf(1)\n\n43"
  },
  {
    "unit_id": "controlflow.rst-56",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Lambda Expressions"
    ],
    "concept_text": "The above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument.  For instance, :meth:`list.sort`",
    "example_code": "pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n\npairs.sort(key=lambda pair: pair[1])\n\npairs\n\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"
  },
  {
    "unit_id": "controlflow.rst-57",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Documentation Strings"
    ],
    "concept_text": "",
    "example_code": "single: docstrings\n\nsingle: documentation strings\n\nsingle: strings, documentation"
  },
  {
    "unit_id": "controlflow.rst-58",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Documentation Strings"
    ],
    "concept_text": "Here are some conventions about the content and formatting of documentation\nstrings.\n\nThe first line should always be a short, concise summary of the object's\npurpose.  For brevity, it should not explicitly state the object's name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a function's operation).  This line should begin with a capital\nletter and end with a period.\n\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the object's calling\nconventions, its side effects, etc.\n\nThe Python parser does not strip indentation from multi-line string literals in\nPython, so tools that process documentation have to strip indentation if\ndesired.  This is done using the following convention. The first non-blank line\n*after* the first line of the string determines the amount of indentation for\nthe entire documentation string.  (We can't use the first line since it is\ngenerally adjacent to the string's opening quotes so its indentation is not\napparent in the string literal.)  Whitespace \"equivalent\" to this indentation is\nthen stripped from the start of all lines of the string.  Lines that are\nindented less should not occur, but if they occur all their leading whitespace\nshould be stripped.  Equivalence of whitespace should be tested after expansion\nof tabs (to 8 spaces, normally).",
    "example_code": "def my_function():\n\n    \"\"\"Do nothing, but document it.\n\n...\n\n    No, really, it doesn't do anything.\n\n    \"\"\"\n\n    pass\n\n...\n\nprint(my_function.__doc__)\n\nDo nothing, but document it.\n\n\nNo, really, it doesn't do anything."
  },
  {
    "unit_id": "controlflow.rst-59",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Annotations"
    ],
    "concept_text": "",
    "example_code": "pair: function; annotations\n\nsingle: ->; function annotations\n\nsingle: : (colon); function annotations"
  },
  {
    "unit_id": "controlflow.rst-60",
    "source_file": "controlflow.rst",
    "topic_hierarchy": [
      "More on Defining Functions",
      "Function Annotations"
    ],
    "concept_text": ":ref:`Function annotations <function>` are completely optional metadata\ninformation about the types used by user-defined functions (see :pep:`3107` and\n:pep:`484` for more information).\n\n:term:`Annotations <function annotation>` are stored in the :attr:`!__annotations__`\nattribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal ``->``, followed by an expression, between the parameter\nlist and the colon denoting the end of the :keyword:`def` statement.  The\nfollowing example has a required argument, an optional argument, and the return",
    "example_code": "def f(ham: str, eggs: str = 'eggs') -> str:\n\n    print(\"Annotations:\", f.__annotations__)\n\n    print(\"Arguments:\", ham, eggs)\n\n    return ham + ' and ' + eggs\n\n...\n\nf('spam')\n\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\n\nArguments: spam eggs\n\n'spam and eggs'"
  },
  {
    "unit_id": "datastructures.rst-0",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists"
    ],
    "concept_text": "The list data type has some more methods.  Here are all of the methods of list\nobjects:\n\n\n:noindex:\n\nAdd an item to the end of the list.  Similar to ``a[len(a):] = [x]``.\n\n\n:noindex:\n\nExtend the list by appending all the items from the iterable.  Similar to\n``a[len(a):] = iterable``.\n\n\n:noindex:\n\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so ``a.insert(0, x)`` inserts at the front of\nthe list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``.\n\n\n:noindex:\n\nRemove the first item from the list whose value is equal to *x*.  It raises a\n:exc:`ValueError` if there is no such item.\n\n\n:noindex:\n\nRemove the item at the given position in the list, and return it.  If no index\nis specified, ``a.pop()`` removes and returns the last item in the list.\nIt raises an :exc:`IndexError` if the list is empty or the index is\noutside the list range.\n\n\n:noindex:\n\nRemove all items from the list.  Similar to ``del a[:]``.\n\n\n:noindex:\n\nReturn zero-based index in the list of the first item whose value is equal to *x*.\nRaises a :exc:`ValueError` if there is no such item.\n\nThe optional arguments *start* and *end* are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the *start* argument.\n\n\n:noindex:\n\nReturn the number of times *x* appears in the list.\n\n\n:noindex:\n\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see :func:`sorted` for their explanation).\n\n\n:noindex:\n\nReverse the elements of the list in place.\n\n\n:noindex:\n\nReturn a shallow copy of the list.  Similar to ``a[:]``.",
    "example_code": "fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n\nfruits.count('apple')\n\n2\n\nfruits.count('tangerine')\n\n0\n\nfruits.index('banana')\n\n3\n\nfruits.index('banana', 4)  # Find next banana starting at position 4\n\n6\n\nfruits.reverse()\n\nfruits\n\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n\nfruits.append('grape')\n\nfruits\n\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n\nfruits.sort()\n\nfruits\n\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n\nfruits.pop()\n\n'pear'"
  },
  {
    "unit_id": "datastructures.rst-1",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Using Lists as Stacks"
    ],
    "concept_text": "The list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (\"last-in, first-out\").  To add an\nitem to the top of the stack, use :meth:`!append`.  To retrieve an item from the",
    "example_code": "stack = [3, 4, 5]\n\nstack.append(6)\n\nstack.append(7)\n\nstack\n\n[3, 4, 5, 6, 7]\n\nstack.pop()\n\n7\n\nstack\n\n[3, 4, 5, 6]\n\nstack.pop()\n\n6\n\nstack.pop()\n\n5\n\nstack\n\n[3, 4]"
  },
  {
    "unit_id": "datastructures.rst-2",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Using Lists as Queues"
    ],
    "concept_text": "It is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (\"first-in, first-out\"); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\n\nTo implement a queue, use :class:`collections.deque` which was designed to",
    "example_code": "from collections import deque\n\nqueue = deque([\"Eric\", \"John\", \"Michael\"])\n\nqueue.append(\"Terry\")           # Terry arrives\n\nqueue.append(\"Graham\")          # Graham arrives\n\nqueue.popleft()                 # The first to arrive now leaves\n\n'Eric'\n\nqueue.popleft()                 # The second to arrive now leaves\n\n'John'\n\nqueue                           # Remaining queue in order of arrival\n\ndeque(['Michael', 'Terry', 'Graham'])"
  },
  {
    "unit_id": "datastructures.rst-3",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "List comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.",
    "example_code": "squares = []\n\nfor x in range(10):\n\n    squares.append(x**2)\n\n...\n\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
  },
  {
    "unit_id": "datastructures.rst-4",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "Note that this creates (or overwrites) a variable named ``x`` that still exists\nafter the loop completes.  We can calculate the list of squares without any",
    "example_code": "squares = list(map(lambda x: x**2, range(10)))"
  },
  {
    "unit_id": "datastructures.rst-5",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "",
    "example_code": "squares = [x**2 for x in range(10)]"
  },
  {
    "unit_id": "datastructures.rst-6",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "which is more concise and readable.\n\nA list comprehension consists of brackets containing an expression followed\nby a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!if`\nclauses.  The result will be a new list resulting from evaluating the expression\nin the context of the :keyword:`!for` and :keyword:`!if` clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not",
    "example_code": "[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
  },
  {
    "unit_id": "datastructures.rst-7",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "",
    "example_code": "combs = []\n\nfor x in [1,2,3]:\n\n    for y in [3,1,4]:\n\n        if x != y:\n\n            combs.append((x, y))\n\n...\n\ncombs\n\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
  },
  {
    "unit_id": "datastructures.rst-8",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "Note how the order of the :keyword:`for` and :keyword:`if` statements is the\nsame in both these snippets.\n\nIf the expression is a tuple (e.g. the ``(x, y)`` in the previous example),",
    "example_code": "vec = [-4, -2, 0, 2, 4]\n\n[x*2 for x in vec]\n\n[-8, -4, 0, 4, 8]\n\n[x for x in vec if x >= 0]\n\n[0, 2, 4]\n\n[abs(x) for x in vec]\n\n[4, 2, 0, 2, 4]\n\nfreshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n\n[weapon.strip() for weapon in freshfruit]\n\n['banana', 'loganberry', 'passion fruit']\n\n[(x, x**2) for x in range(6)]\n\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n\n[x, x**2 for x in range(6)]\n\n  File \"<stdin>\", line 1\n\n    [x, x**2 for x in range(6)]\n\n     ^^^^^^^\n\nSyntaxError: did you forget parentheses around the comprehension target?\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]"
  },
  {
    "unit_id": "datastructures.rst-9",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "List Comprehensions"
    ],
    "concept_text": "",
    "example_code": "from math import pi\n\n[str(round(pi, i)) for i in range(1, 6)]\n\n['3.1', '3.14', '3.142', '3.1416', '3.14159']"
  },
  {
    "unit_id": "datastructures.rst-10",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Nested List Comprehensions"
    ],
    "concept_text": "The initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\n\nConsider the following example of a 3x4 matrix implemented as a list of",
    "example_code": "matrix = [\n\n    [1, 2, 3, 4],\n\n    [5, 6, 7, 8],\n\n    [9, 10, 11, 12],\n\n]"
  },
  {
    "unit_id": "datastructures.rst-11",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Nested List Comprehensions"
    ],
    "concept_text": "",
    "example_code": "[[row[i] for row in matrix] for i in range(4)]\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
  },
  {
    "unit_id": "datastructures.rst-12",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Nested List Comprehensions"
    ],
    "concept_text": "As we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the :keyword:`for` that follows it, so this example is",
    "example_code": "transposed = []\n\nfor i in range(4):\n\n    transposed.append([row[i] for row in matrix])\n\n...\n\ntransposed\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
  },
  {
    "unit_id": "datastructures.rst-13",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Nested List Comprehensions"
    ],
    "concept_text": "",
    "example_code": "transposed = []\n\nfor i in range(4):\n\n    transposed_row = []\n\n    for row in matrix:\n\n        transposed_row.append(row[i])\n\n    transposed.append(transposed_row)\n\n...\n\ntransposed\n\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
  },
  {
    "unit_id": "datastructures.rst-14",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Lists",
      "Nested List Comprehensions"
    ],
    "concept_text": "In the real world, you should prefer built-in functions to complex flow statements.",
    "example_code": "list(zip(*matrix))\n\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
  },
  {
    "unit_id": "datastructures.rst-15",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "The :keyword:`!del` statement"
    ],
    "concept_text": "There is a way to remove an item from a list given its index instead of its\nvalue: the :keyword:`del` statement.  This differs from the :meth:`!pop` method\nwhich returns a value.  The :keyword:`!del` statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment",
    "example_code": "a = [-1, 1, 66.25, 333, 333, 1234.5]\n\ndel a[0]\n\na\n\n[1, 66.25, 333, 333, 1234.5]\n\ndel a[2:4]\n\na\n\n[1, 66.25, 1234.5]\n\ndel a[:]\n\na\n\n[]"
  },
  {
    "unit_id": "datastructures.rst-16",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "The :keyword:`!del` statement"
    ],
    "concept_text": "",
    "example_code": "del a"
  },
  {
    "unit_id": "datastructures.rst-17",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Tuples and Sequences"
    ],
    "concept_text": "We saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of *sequence* data types (see\n:ref:`typesseq`).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the\n*tuple*.",
    "example_code": "t = 12345, 54321, 'hello!'\n\nt[0]\n\n12345\n\nt\n\n(12345, 54321, 'hello!')\n\nu = t, (1, 2, 3, 4, 5)\n\nu\n\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n\nt[0] = 88888\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\nv = ([1, 2, 3], [3, 2, 1])\n\nv\n\n([1, 2, 3], [3, 2, 1])"
  },
  {
    "unit_id": "datastructures.rst-18",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Tuples and Sequences"
    ],
    "concept_text": "As you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\n\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are :term:`immutable`, and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of :func:`namedtuples <collections.namedtuple>`).\nLists are :term:`mutable`, and their elements are usually homogeneous and are\naccessed by iterating over the list.\n\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value",
    "example_code": "empty = ()\n\nsingleton = 'hello',    # <-- note trailing comma\n\nlen(empty)\n\n0\n\nlen(singleton)\n\n1\n\nsingleton\n\n('hello',)"
  },
  {
    "unit_id": "datastructures.rst-19",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Tuples and Sequences"
    ],
    "concept_text": "The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple packing*:\nthe values ``12345``, ``54321`` and ``'hello!'`` are packed together in a tuple.",
    "example_code": "x, y, z = t"
  },
  {
    "unit_id": "datastructures.rst-20",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Sets"
    ],
    "concept_text": "Python also includes a data type for *sets*.  A set is an unordered collection\nwith no duplicate elements.  Basic uses include membership testing and\neliminating duplicate entries.  Set objects also support mathematical operations\nlike union, intersection, difference, and symmetric difference.\n\nCurly braces or the :func:`set` function can be used to create sets.  Note: to\ncreate an empty set you have to use ``set()``, not ``{}``; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.",
    "example_code": "basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n\nprint(basket)                      # show that duplicates have been removed\n\n{'orange', 'banana', 'pear', 'apple'}\n\n'orange' in basket                 # fast membership testing\n\nTrue\n\n'crabgrass' in basket\n\nFalse\n\n\n>>>\n\na = set('abracadabra')\n\nb = set('alacazam')\n\na                                  # unique letters in a\n\n{'a', 'r', 'b', 'c', 'd'}\n\na - b                              # letters in a but not in b\n\n{'r', 'd', 'b'}\n\na | b                              # letters in a or b or both\n\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n\na & b                              # letters in both a and b\n\n{'a', 'c'}\n\na ^ b                              # letters in a or b but not both\n\n{'r', 'd', 'b', 'm', 'z', 'l'}"
  },
  {
    "unit_id": "datastructures.rst-21",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Sets"
    ],
    "concept_text": "Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions",
    "example_code": "a = {x for x in 'abracadabra' if x not in 'abc'}\n\na\n\n{'r', 'd'}"
  },
  {
    "unit_id": "datastructures.rst-22",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Dictionaries"
    ],
    "concept_text": "Another useful data type built into Python is the *dictionary* (see\n:ref:`typesmapping`). Dictionaries are sometimes found in other languages as\n\"associative memories\" or \"associative arrays\".  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by *keys*, which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou can't use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like :meth:`!append` and\n:meth:`!extend`.\n\nIt is best to think of a dictionary as a set of *key: value* pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: ``{}``. Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\n\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with ``del``. If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\n\nPerforming ``list(d)`` on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use\n``sorted(d)`` instead). To check whether a single key is in the\ndictionary, use the :keyword:`in` keyword.",
    "example_code": "tel = {'jack': 4098, 'sape': 4139}\n\ntel['guido'] = 4127\n\ntel\n\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n\ntel['jack']\n\n4098\n\ndel tel['sape']\n\ntel['irv'] = 4127\n\ntel\n\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n\nlist(tel)\n\n['jack', 'guido', 'irv']\n\nsorted(tel)\n\n['guido', 'irv', 'jack']\n\n'guido' in tel\n\nTrue\n\n'jack' not in tel\n\nFalse"
  },
  {
    "unit_id": "datastructures.rst-23",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Dictionaries"
    ],
    "concept_text": "The :func:`dict` constructor builds dictionaries directly from sequences of",
    "example_code": "dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n\n{'sape': 4139, 'guido': 4127, 'jack': 4098}"
  },
  {
    "unit_id": "datastructures.rst-24",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Dictionaries"
    ],
    "concept_text": "In addition, dict comprehensions can be used to create dictionaries from",
    "example_code": "{x: x**2 for x in (2, 4, 6)}\n\n{2: 4, 4: 16, 6: 36}"
  },
  {
    "unit_id": "datastructures.rst-25",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Dictionaries"
    ],
    "concept_text": "When the keys are simple strings, it is sometimes easier to specify pairs using",
    "example_code": "dict(sape=4139, guido=4127, jack=4098)\n\n{'sape': 4139, 'guido': 4127, 'jack': 4098}"
  },
  {
    "unit_id": "datastructures.rst-26",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "When looping through dictionaries, the key and corresponding value can be",
    "example_code": "knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n\nfor k, v in knights.items():\n\n    print(k, v)\n\n...\n\ngallahad the pure\n\nrobin the brave"
  },
  {
    "unit_id": "datastructures.rst-27",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "When looping through a sequence, the position index and corresponding value can",
    "example_code": "for i, v in enumerate(['tic', 'tac', 'toe']):\n\n    print(i, v)\n\n...\n\n0 tic\n\n1 tac\n\n2 toe"
  },
  {
    "unit_id": "datastructures.rst-28",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "To loop over two or more sequences at the same time, the entries can be paired",
    "example_code": "questions = ['name', 'quest', 'favorite color']\n\nanswers = ['lancelot', 'the holy grail', 'blue']\n\nfor q, a in zip(questions, answers):\n\n    print('What is your {0}?  It is {1}.'.format(q, a))\n\n...\n\nWhat is your name?  It is lancelot.\n\nWhat is your quest?  It is the holy grail.\n\nWhat is your favorite color?  It is blue."
  },
  {
    "unit_id": "datastructures.rst-29",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "To loop over a sequence in reverse, first specify the sequence in a forward",
    "example_code": "for i in reversed(range(1, 10, 2)):\n\n    print(i)\n\n...\n\n9\n\n7\n\n5\n\n3\n\n1"
  },
  {
    "unit_id": "datastructures.rst-30",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "To loop over a sequence in sorted order, use the :func:`sorted` function which",
    "example_code": "basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n\nfor i in sorted(basket):\n\n    print(i)\n\n...\n\napple\n\napple\n\nbanana\n\norange\n\norange\n\npear"
  },
  {
    "unit_id": "datastructures.rst-31",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "Using :func:`set` on a sequence eliminates duplicate elements. The use of\n:func:`sorted` in combination with :func:`set` over a sequence is an idiomatic",
    "example_code": "basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n\nfor f in sorted(set(basket)):\n\n    print(f)\n\n...\n\napple\n\nbanana\n\norange\n\npear"
  },
  {
    "unit_id": "datastructures.rst-32",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Looping Techniques"
    ],
    "concept_text": "It is sometimes tempting to change a list while you are looping over it;",
    "example_code": "import math\n\nraw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n\nfiltered_data = []\n\nfor value in raw_data:\n\n    if not math.isnan(value):\n\n        filtered_data.append(value)\n\n...\n\nfiltered_data\n\n[56.2, 51.7, 55.3, 52.5, 47.8]"
  },
  {
    "unit_id": "datastructures.rst-33",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "More on Conditions"
    ],
    "concept_text": "The conditions used in ``while`` and ``if`` statements can contain any\noperators, not just comparisons.\n\n\nThe comparison operators ``in`` and ``not in`` are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators ``is``\nand ``is not`` compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\n\nComparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` is\nless than ``b`` and moreover ``b`` equals ``c``.\n\nComparisons may be combined using the Boolean operators ``and`` and ``or``, and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith ``not``.  These have lower priorities than comparison operators; between\nthem, ``not`` has the highest priority and ``or`` the lowest, so that ``A and\nnot B or C`` is equivalent to ``(A and (not B)) or C``. As always, parentheses\ncan be used to express the desired composition.\n\nThe Boolean operators ``and`` and ``or`` are so-called *short-circuit*\noperators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if ``A`` and ``C`` are\ntrue but ``B`` is false, ``A and B and C`` does not evaluate the expression\n``C``.  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\n\nIt is possible to assign the result of a comparison or other Boolean expression",
    "example_code": "string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n\nnon_null = string1 or string2 or string3\n\nnon_null\n\n'Trondheim'"
  },
  {
    "unit_id": "datastructures.rst-34",
    "source_file": "datastructures.rst",
    "topic_hierarchy": [
      "Comparing Sequences and Other Types"
    ],
    "concept_text": "Sequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses *lexicographical* ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.",
    "example_code": "(1, 2, 3)              < (1, 2, 4)\n\n[1, 2, 3]              < [1, 2, 4]\n\n'ABC' < 'C' < 'Pascal' < 'Python'\n\n(1, 2, 3, 4)           < (1, 2, 4)\n\n(1, 2)                 < (1, 2, -1)\n\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
  },
  {
    "unit_id": "modules.rst-0",
    "source_file": "modules.rst",
    "topic_hierarchy": [],
    "concept_text": "*******\nModules\n*******\n\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a *script*.  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that you've written in several programs without copying its\ndefinition into each program.\n\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\n*module*; definitions from a module can be *imported* into other modules or into\nthe *main* module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\n\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix :file:`.py` appended.  Within a module, the\nmodule's name (as a string) is available as the value of the global variable\n``__name__``.  For instance, use your favorite text editor to create a file",
    "example_code": "def fib(n):\n\n    \"\"\"Write Fibonacci series up to n.\"\"\"\n\n    a, b = 0, 1\n\n    while a < n:\n\n        print(a, end=' ')\n\n        a, b = b, a+b\n\n    print()\n\n\ndef fib2(n):\n\n    \"\"\"Return Fibonacci series up to n.\"\"\"\n\n    result = []\n\n    a, b = 0, 1\n\n    while a < n:\n\n        result.append(a)\n\n        a, b = b, a+b\n\n    return result"
  },
  {
    "unit_id": "modules.rst-1",
    "source_file": "modules.rst",
    "topic_hierarchy": [],
    "concept_text": "Now enter the Python interpreter and import this module with the following",
    "example_code": "import fibo"
  },
  {
    "unit_id": "modules.rst-2",
    "source_file": "modules.rst",
    "topic_hierarchy": [],
    "concept_text": "This does not add the names of the functions defined in ``fibo``  directly to\nthe current :term:`namespace` (see :ref:`tut-scopes` for more details);\nit only adds the module name ``fibo`` there. Using",
    "example_code": "fibo.fib(1000)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n\nfibo.fib2(100)\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n\nfibo.__name__\n\n'fibo'"
  },
  {
    "unit_id": "modules.rst-3",
    "source_file": "modules.rst",
    "topic_hierarchy": [],
    "concept_text": "",
    "example_code": "fib = fibo.fib\n\nfib(500)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
  },
  {
    "unit_id": "modules.rst-4",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules"
    ],
    "concept_text": "A module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe *first* time the module name is encountered in an import statement. [#]_\n(They are also run if the file is executed as a script.)\n\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a user's global variables. On the other hand, if you know what you are\ndoing you can touch a module's global variables with the same notation used to\nrefer to its functions, ``modname.itemname``.\n\nModules can import other modules.  It is customary but not required to place all\n:keyword:`import` statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the module's global namespace.\n\nThere is a variant of the :keyword:`import` statement that imports names from a",
    "example_code": "from fibo import fib, fib2\n\nfib(500)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
  },
  {
    "unit_id": "modules.rst-5",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules"
    ],
    "concept_text": "This does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, ``fibo`` is not defined).",
    "example_code": "from fibo import *\n\nfib(500)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
  },
  {
    "unit_id": "modules.rst-6",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules"
    ],
    "concept_text": "This imports all names except those beginning with an underscore (``_``).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\n\nNote that in general the practice of importing ``*`` from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\n\nIf the module name is followed by :keyword:`!as`, then the name\nfollowing :keyword:`!as` is bound directly to the imported module.",
    "example_code": "import fibo as fib\n\nfib.fib(500)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
  },
  {
    "unit_id": "modules.rst-7",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules"
    ],
    "concept_text": "This is effectively importing the module in the same way that ``import fibo``\nwill do, with the only difference of it being available as ``fib``.",
    "example_code": "from fibo import fib as fibonacci\n\nfibonacci(500)\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
  },
  {
    "unit_id": "modules.rst-8",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules"
    ],
    "concept_text": "",
    "example_code": "For efficiency reasons, each module is only imported once per interpreter\n\nsession.  Therefore, if you change your modules, you must restart the\n\ninterpreter -- or, if it's just one module you want to test interactively,\n\nuse :func:`importlib.reload`, e.g. ``import importlib;\n\nimportlib.reload(modulename)``."
  },
  {
    "unit_id": "modules.rst-9",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules",
      "Executing modules as scripts"
    ],
    "concept_text": "",
    "example_code": "python fibo.py <arguments>"
  },
  {
    "unit_id": "modules.rst-10",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules",
      "Executing modules as scripts"
    ],
    "concept_text": "the code in the module will be executed, just as if you imported it, but with\nthe ``__name__`` set to ``\"__main__\"``.  That means that by adding this code at",
    "example_code": "if __name__ == \"__main__\":\n\n    import sys\n\n    fib(int(sys.argv[1]))"
  },
  {
    "unit_id": "modules.rst-11",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules",
      "Executing modules as scripts"
    ],
    "concept_text": "you can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the \"main\" file:\n\n\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34",
    "example_code": "import fibo\n\n>>>"
  },
  {
    "unit_id": "modules.rst-12",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "More on Modules",
      "The Module Search Path"
    ],
    "concept_text": "When a module named :mod:`!spam` is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\n:data:`sys.builtin_module_names`. If not found, it then searches for a file\nnamed :file:`spam.py` in a list of directories given by the variable\n:data:`sys.path`.  :data:`sys.path` is initialized from these locations:\n\n* The directory containing the input script (or the current directory when no\nfile is specified).\n* :envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the\nshell variable :envvar:`PATH`).\n* The installation-dependent default (by convention including a\n``site-packages`` directory, handled by the :mod:`site` module).\n\nMore details are at :ref:`sys-path-init`.",
    "example_code": "On file systems which support symlinks, the directory containing the input\n\nscript is calculated after the symlink is followed. In other words the\n\ndirectory containing the symlink is **not** added to the module search path."
  },
  {
    "unit_id": "modules.rst-13",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Standard Modules"
    ],
    "concept_text": "Python comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (\"Library Reference\" hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the :mod:`winreg` module is only\nprovided on Windows systems. One particular module deserves some attention:\n:mod:`sys`, which is built into every Python interpreter.  The variables\n``sys.ps1`` and ``sys.ps2`` define the strings used as primary and secondary",
    "example_code": "import sys\n\nsys.ps1\n\n'>>> '\n\nsys.ps2\n\n'... '\n\nsys.ps1 = 'C> '\n\nC> print('Yuck!')\n\nYuck!\n\nC>"
  },
  {
    "unit_id": "modules.rst-14",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Standard Modules"
    ],
    "concept_text": "These two variables are only defined if the interpreter is in interactive mode.\n\nThe variable ``sys.path`` is a list of strings that determines the interpreter's\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable :envvar:`PYTHONPATH`, or from a built-in default if\n:envvar:`PYTHONPATH` is not set.  You can modify it using standard list",
    "example_code": "import sys\n\nsys.path.append('/ufs/guido/lib/python')"
  },
  {
    "unit_id": "modules.rst-15",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "The :func:`dir` Function"
    ],
    "concept_text": "The built-in function :func:`dir` is used to find out which names a module",
    "example_code": "import fibo, sys\n\ndir(fibo)\n\n['__name__', 'fib', 'fib2']\n\ndir(sys)  # doctest: +NORMALIZE_WHITESPACE\n\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n\n '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n\n '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n\n '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n\n '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n\n 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n\n 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n\n 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n\n 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n\n 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n\n 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n\n 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n\n 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n\n 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n\n 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n\n 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n\n 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n\n 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n\n 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n\n 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n\n 'warnoptions']"
  },
  {
    "unit_id": "modules.rst-16",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "The :func:`dir` Function"
    ],
    "concept_text": "",
    "example_code": "a = [1, 2, 3, 4, 5]\n\nimport fibo\n\nfib = fibo.fib\n\ndir()\n\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"
  },
  {
    "unit_id": "modules.rst-17",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "The :func:`dir` Function"
    ],
    "concept_text": "Note that it lists all types of names: variables, modules, functions, etc.\n\n\n:func:`dir` does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module",
    "example_code": "import builtins\n\ndir(builtins)  # doctest: +NORMALIZE_WHITESPACE\n\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n\n 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n\n 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n\n 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n\n 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n\n 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n\n 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n\n 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n\n 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n\n 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n\n 'NotImplementedError', 'OSError', 'OverflowError',\n\n 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n\n 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n\n 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n\n 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n\n 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n\n 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n\n 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n\n '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n\n 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n\n 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n\n 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n\n 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n\n 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n\n 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n\n 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n\n 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n\n 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n\n 'zip']"
  },
  {
    "unit_id": "modules.rst-18",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "Packages are a way of structuring Python's module namespace by using \"dotted\nmodule names\".  For example, the module name :mod:`!A.B` designates a submodule\nnamed ``B`` in a package named ``A``.  Just like the use of modules saves the\nauthors of different modules from having to worry about each other's global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach other's module names.\n\nSuppose you want to design a collection of modules (a \"package\") for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: :file:`.wav`,\n:file:`.aiff`, :file:`.au`), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Here's a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\n\n\nsound/                          Top-level package\n__init__.py               Initialize the sound package\nformats/                  Subpackage for file format conversions\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\neffects/                  Subpackage for sound effects\n__init__.py\necho.py\nsurround.py\nreverse.py\nfilters/                  Subpackage for filters\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n\nWhen importing the package, Python searches through the directories on\n``sys.path`` looking for the package subdirectory.\n\nThe :file:`__init__.py` files are required to make Python treat directories\ncontaining the file as packages (unless using a :term:`namespace package`, a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as ``string``, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, :file:`__init__.py` can just be\nan empty file, but it can also execute initialization code for the package or\nset the ``__all__`` variable, described later.\n\nUsers of the package can import individual modules from the package, for",
    "example_code": "import sound.effects.echo"
  },
  {
    "unit_id": "modules.rst-19",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "This loads the submodule :mod:`!sound.effects.echo`.  It must be referenced with",
    "example_code": "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"
  },
  {
    "unit_id": "modules.rst-20",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "",
    "example_code": "from sound.effects import echo"
  },
  {
    "unit_id": "modules.rst-21",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "This also loads the submodule :mod:`!echo`, and makes it available without its",
    "example_code": "echo.echofilter(input, output, delay=0.7, atten=4)"
  },
  {
    "unit_id": "modules.rst-22",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "",
    "example_code": "from sound.effects.echo import echofilter"
  },
  {
    "unit_id": "modules.rst-23",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages"
    ],
    "concept_text": "Again, this loads the submodule :mod:`!echo`, but this makes its function",
    "example_code": "echofilter(input, output, delay=0.7, atten=4)"
  },
  {
    "unit_id": "modules.rst-24",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages",
      "Importing \\* From a Package"
    ],
    "concept_text": "Now what happens when the user writes ``from sound.effects import *``?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\n\nThe only solution is for the package author to provide an explicit index of the\npackage.  The :keyword:`import` statement uses the following convention: if a package's\n:file:`__init__.py` code defines a list named ``__all__``, it is taken to be the\nlist of module names that should be imported when ``from package import *`` is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they don't see a use for importing \\* from their package.  For\nexample, the file :file:`sound/effects/__init__.py` could contain the following",
    "example_code": "__all__ = [\"echo\", \"surround\", \"reverse\"]"
  },
  {
    "unit_id": "modules.rst-25",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages",
      "Importing \\* From a Package"
    ],
    "concept_text": "This would mean that ``from sound.effects import *`` would import the three\nnamed submodules of the :mod:`!sound.effects` package.\n\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a ``reverse`` function to the\n:file:`sound/effects/__init__.py` file, the ``from sound.effects import *``\nwould only import the two submodules ``echo`` and ``surround``, but *not* the\n``reverse`` submodule, because it is shadowed by the locally defined",
    "example_code": "__all__ = [\n\n    \"echo\",      # refers to the 'echo.py' file\n\n    \"surround\",  # refers to the 'surround.py' file\n\n    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n\n]\n\n\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\n\n    return msg[::-1]    #     in the case of a 'from sound.effects import *'"
  },
  {
    "unit_id": "modules.rst-26",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages",
      "Importing \\* From a Package"
    ],
    "concept_text": "If ``__all__`` is not defined, the statement ``from sound.effects import *``\ndoes *not* import all submodules from the package :mod:`!sound.effects` into the\ncurrent namespace; it only ensures that the package :mod:`!sound.effects` has\nbeen imported (possibly running any initialization code in :file:`__init__.py`)\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by :file:`__init__.py`.  It\nalso includes any submodules of the package that were explicitly loaded by",
    "example_code": "import sound.effects.echo\n\nimport sound.effects.surround\n\nfrom sound.effects import *"
  },
  {
    "unit_id": "modules.rst-27",
    "source_file": "modules.rst",
    "topic_hierarchy": [
      "Packages",
      "Intra-package References"
    ],
    "concept_text": "When packages are structured into subpackages (as with the :mod:`!sound` package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module :mod:`!sound.filters.vocoder` needs to use\nthe :mod:`!echo` module in the :mod:`!sound.effects` package, it can use ``from\nsound.effects import echo``.\n\nYou can also write relative imports, with the ``from module import name`` form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the :mod:`!surround`",
    "example_code": "from . import echo\n\nfrom .. import formats\n\nfrom ..filters import equalizer"
  },
  {
    "unit_id": "inputoutput.rst-0",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting"
    ],
    "concept_text": "So far we've encountered two ways of writing values: *expression statements* and\nthe :func:`print` function.  (A third way is using the :meth:`~io.TextIOBase.write` method\nof file objects; the standard output file can be referenced as ``sys.stdout``.\nSee the Library Reference for more information on this.)\n\nOften you'll want more control over the formatting of your output than simply\nprinting space-separated values. There are several ways to format output.\n\n* To use :ref:`formatted string literals <tut-f-strings>`, begin a string\nwith ``f`` or ``F`` before the opening quotation mark or triple quotation mark.\nInside this string, you can write a Python expression between ``{`` and ``}``\ncharacters that can refer to variables or literal values.",
    "example_code": "year = 2016\n\nevent = 'Referendum'\n\nf'Results of the {year} {event}'\n\n'Results of the 2016 Referendum'"
  },
  {
    "unit_id": "inputoutput.rst-1",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting"
    ],
    "concept_text": "* The :meth:`str.format` method of strings requires more manual\neffort.  You'll still use ``{`` and ``}`` to mark where a variable\nwill be substituted and can provide detailed formatting directives,\nbut you'll also need to provide the information to be formatted. In the following code\nblock there are two examples of how to format variables:",
    "example_code": "yes_votes = 42_572_654\n\ntotal_votes = 85_705_149\n\npercentage = yes_votes / total_votes\n\n'{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)\n\n' 42572654 YES votes  49.67%'"
  },
  {
    "unit_id": "inputoutput.rst-2",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting"
    ],
    "concept_text": "Notice how the ``yes_votes`` are padded with spaces and a negative sign only for negative numbers.\nThe example also prints ``percentage`` multiplied by 100, with 2 decimal\nplaces and followed by a percent sign (see :ref:`formatspec` for details).\n\n\n* Finally, you can do all the string handling yourself by using string slicing and\nconcatenation operations to create any layout you can imagine.  The\nstring type has some methods that perform useful operations for padding\nstrings to a given column width.\n\nWhen you don't need fancy output but just want a quick display of some\nvariables for debugging purposes, you can convert any value to a string with\nthe :func:`repr` or :func:`str` functions.\n\nThe :func:`str` function is meant to return representations of values which are\nfairly human-readable, while :func:`repr` is meant to generate representations\nwhich can be read by the interpreter (or will force a :exc:`SyntaxError` if\nthere is no equivalent syntax).  For objects which don't have a particular\nrepresentation for human consumption, :func:`str` will return the same value as\n:func:`repr`.  Many values, such as numbers or structures like lists and\ndictionaries, have the same representation using either function.  Strings, in\nparticular, have two distinct representations.",
    "example_code": "s = 'Hello, world.'\n\nstr(s)\n\n'Hello, world.'\n\nrepr(s)\n\n\"'Hello, world.'\"\n\nstr(1/7)\n\n'0.14285714285714285'\n\nx = 10 * 3.25\n\ny = 200 * 200\n\ns = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n\nprint(s)\n\nThe value of x is 32.5, and y is 40000...\n\nhello = 'hello, world\\n'\n\nhellos = repr(hello)\n\nprint(hellos)\n\n'hello, world\\n'\n\nrepr((x, y, ('spam', 'eggs')))\n\n\"(32.5, 40000, ('spam', 'eggs'))\""
  },
  {
    "unit_id": "inputoutput.rst-3",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting"
    ],
    "concept_text": "The :mod:`string` module contains a :class:`~string.Template` class that offers\nyet another way to substitute values into strings, using placeholders like\n``$x`` and replacing them with values from a dictionary, but offers much less\ncontrol of the formatting.",
    "example_code": "single: formatted string literal\n\nsingle: interpolated string literal\n\nsingle: string; formatted literal\n\nsingle: string; interpolated literal\n\nsingle: f-string\n\nsingle: fstring"
  },
  {
    "unit_id": "inputoutput.rst-4",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Formatted String Literals"
    ],
    "concept_text": ":ref:`Formatted string literals <f-strings>` (also called f-strings for\nshort) let you include the value of Python expressions inside a string by\nprefixing the string with ``f`` or ``F`` and writing expressions as\n``{expression}``.\n\nAn optional format specifier can follow the expression. This allows greater\ncontrol over how the value is formatted. The following example rounds pi to",
    "example_code": "import math\n\nprint(f'The value of pi is approximately {math.pi:.3f}.')\n\nThe value of pi is approximately 3.142."
  },
  {
    "unit_id": "inputoutput.rst-5",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Formatted String Literals"
    ],
    "concept_text": "Passing an integer after the ``':'`` will cause that field to be a minimum",
    "example_code": "table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n\nfor name, phone in table.items():\n\n    print(f'{name:10} ==> {phone:10d}')\n\n...\n\nSjoerd     ==>       4127\n\nJack       ==>       4098\n\nDcab       ==>       7678"
  },
  {
    "unit_id": "inputoutput.rst-6",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Formatted String Literals"
    ],
    "concept_text": "Other modifiers can be used to convert the value before it is formatted.\n``'!a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'``",
    "example_code": "animals = 'eels'\n\nprint(f'My hovercraft is full of {animals}.')\n\nMy hovercraft is full of eels.\n\nprint(f'My hovercraft is full of {animals!r}.')\n\nMy hovercraft is full of 'eels'."
  },
  {
    "unit_id": "inputoutput.rst-7",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "",
    "example_code": "print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n\nWe are the knights who say \"Ni!\""
  },
  {
    "unit_id": "inputoutput.rst-8",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "The brackets and characters within them (called format fields) are replaced with\nthe objects passed into the :meth:`str.format` method.  A number in the\nbrackets can be used to refer to the position of the object passed into the",
    "example_code": "print('{0} and {1}'.format('spam', 'eggs'))\n\nspam and eggs\n\nprint('{1} and {0}'.format('spam', 'eggs'))\n\neggs and spam"
  },
  {
    "unit_id": "inputoutput.rst-9",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "If keyword arguments are used in the :meth:`str.format` method, their values",
    "example_code": "print('This {food} is {adjective}.'.format(\n\n      food='spam', adjective='absolutely horrible'))\n\nThis spam is absolutely horrible."
  },
  {
    "unit_id": "inputoutput.rst-10",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "",
    "example_code": "print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n\n                                                   other='Georg'))\n\nThe story of Bill, Manfred, and Georg."
  },
  {
    "unit_id": "inputoutput.rst-11",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "If you have a really long format string that you don't want to split up, it\nwould be nice if you could reference the variables to be formatted by name\ninstead of by position.  This can be done by simply passing the dict and using",
    "example_code": "table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n\nprint('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n\n      'Dcab: {0[Dcab]:d}'.format(table))\n\nJack: 4098; Sjoerd: 4127; Dcab: 8637678"
  },
  {
    "unit_id": "inputoutput.rst-12",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "This could also be done by passing the ``table`` dictionary as keyword arguments with the ``**``",
    "example_code": "table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n\nprint('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))\n\nJack: 4098; Sjoerd: 4127; Dcab: 8637678"
  },
  {
    "unit_id": "inputoutput.rst-13",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "This is particularly useful in combination with the built-in function",
    "example_code": "table = {k: str(v) for k, v in vars().items()}\n\nmessage = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n\nprint(message.format(**table))\n\n__name__: __main__; __doc__: None; __package__: None; __loader__: ..."
  },
  {
    "unit_id": "inputoutput.rst-14",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "The String format() Method"
    ],
    "concept_text": "As an example, the following lines produce a tidily aligned",
    "example_code": "for x in range(1, 11):\n\n    print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n\n...\n\n 1   1    1\n\n 2   4    8\n\n 3   9   27\n\n 4  16   64\n\n 5  25  125\n\n 6  36  216\n\n 7  49  343\n\n 8  64  512\n\n 9  81  729\n\n10 100 1000"
  },
  {
    "unit_id": "inputoutput.rst-15",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Manual String Formatting"
    ],
    "concept_text": "",
    "example_code": "for x in range(1, 11):\n\n    print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n\n    print(repr(x*x*x).rjust(4))\n\n...\n\n 1   1    1\n\n 2   4    8\n\n 3   9   27\n\n 4  16   64\n\n 5  25  125\n\n 6  36  216\n\n 7  49  343\n\n 8  64  512\n\n 9  81  729\n\n10 100 1000"
  },
  {
    "unit_id": "inputoutput.rst-16",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Manual String Formatting"
    ],
    "concept_text": "(Note that the one space between each column was added by the\nway :func:`print` works: it always adds spaces between its arguments.)\n\nThe :meth:`str.rjust` method of string objects right-justifies a string in a\nfield of a given width by padding it with spaces on the left. There are\nsimilar methods :meth:`str.ljust` and :meth:`str.center`. These methods do\nnot write anything, they just return a new string. If the input string is too\nlong, they don't truncate it, but return it unchanged; this will mess up your\ncolumn lay-out but that's usually better than the alternative, which would be\nlying about a value. (If you really want truncation you can always add a\nslice operation, as in ``x.ljust(n)[:n]``.)\n\nThere is another method, :meth:`str.zfill`, which pads a numeric string on the",
    "example_code": "'12'.zfill(5)\n\n'00012'\n\n'-3.14'.zfill(7)\n\n'-003.14'\n\n'3.14159265359'.zfill(5)\n\n'3.14159265359'"
  },
  {
    "unit_id": "inputoutput.rst-17",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Fancier Output Formatting",
      "Old string formatting"
    ],
    "concept_text": "The % operator (modulo) can also be used for string formatting.\nGiven ``format % values`` (where *format* is a string),\n``%`` conversion specifications in *format* are replaced with\nzero or more elements of *values*.\nThis operation is commonly known as string",
    "example_code": "import math\n\nprint('The value of pi is approximately %5.3f.' % math.pi)\n\nThe value of pi is approximately 3.142."
  },
  {
    "unit_id": "inputoutput.rst-18",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files"
    ],
    "concept_text": "",
    "example_code": "pair: built-in function; open\n\npair: object; file"
  },
  {
    "unit_id": "inputoutput.rst-19",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files"
    ],
    "concept_text": ":func:`open` returns a :term:`file object`, and is most commonly used with\ntwo positional arguments and one keyword argument:\n``open(filename, mode, encoding=None)``",
    "example_code": "f = open('workfile', 'w', encoding=\"utf-8\")"
  },
  {
    "unit_id": "inputoutput.rst-20",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files"
    ],
    "concept_text": ">>> print(f)\n<open file 'workfile', mode 'w' at 80a0960>\n\nThe first argument is a string containing the filename.  The second argument is\nanother string containing a few characters describing the way in which the file\nwill be used.  *mode* can be ``'r'`` when the file will only be read, ``'w'``\nfor only writing (an existing file with the same name will be erased), and\n``'a'`` opens the file for appending; any data written to the file is\nautomatically added to the end.  ``'r+'`` opens the file for both reading and\nwriting. The *mode* argument is optional; ``'r'`` will be assumed if it's\nomitted.\n\nNormally, files are opened in :dfn:`text mode`, that means, you read and write\nstrings from and to the file, which are encoded in a specific *encoding*.\nIf *encoding* is not specified, the default is platform dependent\n(see :func:`open`).\nBecause UTF-8 is the modern de-facto standard, ``encoding=\"utf-8\"`` is\nrecommended unless you know that you need to use a different encoding.\nAppending a ``'b'`` to the mode opens the file in :dfn:`binary mode`.\nBinary mode data is read and written as :class:`bytes` objects.\nYou can not specify *encoding* when opening file in binary mode.\n\nIn text mode, the default when reading is to convert platform-specific line\nendings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When writing in\ntext mode, the default is to convert occurrences of ``\\n`` back to\nplatform-specific line endings.  This behind-the-scenes modification\nto file data is fine for text files, but will corrupt binary data like that in\n:file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when\nreading and writing such files.\n\nIt is good practice to use the :keyword:`with` keyword when dealing\nwith file objects.  The advantage is that the file is properly closed\nafter its suite finishes, even if an exception is raised at some\npoint.  Using :keyword:`!with` is also much shorter than writing",
    "example_code": "with open('workfile', encoding=\"utf-8\") as f:\n\n    read_data = f.read()\n\n\nf.closed\n\nTrue"
  },
  {
    "unit_id": "inputoutput.rst-21",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files"
    ],
    "concept_text": "If you're not using the :keyword:`with` keyword, then you should call\n``f.close()`` to close the file and immediately free up any system\nresources used by it.",
    "example_code": "Calling ``f.write()`` without using the :keyword:`!with` keyword or calling\n\n``f.close()`` **might** result in the arguments\n\nof ``f.write()`` not being completely written to the disk, even if the\n\nprogram exits successfully."
  },
  {
    "unit_id": "inputoutput.rst-22",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files"
    ],
    "concept_text": "See also https://bugs.python.org/issue17852\n\nAfter a file object is closed, either by a :keyword:`with` statement\nor by calling ``f.close()``, attempts to use the file object will",
    "example_code": "f.close()\n\nf.read()\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nValueError: I/O operation on closed file."
  },
  {
    "unit_id": "inputoutput.rst-23",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "The rest of the examples in this section will assume that a file object called\n``f`` has already been created.\n\nTo read a file's contents, call ``f.read(size)``, which reads some quantity of\ndata and returns it as a string (in text mode) or bytes object (in binary mode).\n*size* is an optional numeric argument.  When *size* is omitted or negative, the\nentire contents of the file will be read and returned; it's your problem if the\nfile is twice as large as your machine's memory. Otherwise, at most *size*\ncharacters (in text mode) or *size* bytes (in binary mode) are read and returned.\nIf the end of the file has been reached, ``f.read()`` will return an empty",
    "example_code": "f.read()\n\n'This is the entire file.\\n'\n\nf.read()\n\n''"
  },
  {
    "unit_id": "inputoutput.rst-24",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "``f.readline()`` reads a single line from the file; a newline character (``\\n``)\nis left at the end of the string, and is only omitted on the last line of the\nfile if the file doesn't end in a newline.  This makes the return value\nunambiguous; if ``f.readline()`` returns an empty string, the end of the file\nhas been reached, while a blank line is represented by ``'\\n'``, a string",
    "example_code": "f.readline()\n\n'This is the first line of the file.\\n'\n\nf.readline()\n\n'Second line of the file\\n'\n\nf.readline()\n\n''"
  },
  {
    "unit_id": "inputoutput.rst-25",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "For reading lines from a file, you can loop over the file object. This is memory",
    "example_code": "for line in f:\n\n    print(line, end='')\n\n...\n\nThis is the first line of the file.\n\nSecond line of the file"
  },
  {
    "unit_id": "inputoutput.rst-26",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "If you want to read all the lines of a file in a list you can also use\n``list(f)`` or ``f.readlines()``.\n\n``f.write(string)`` writes the contents of *string* to the file, returning",
    "example_code": "f.write('This is a test\\n')\n\n15"
  },
  {
    "unit_id": "inputoutput.rst-27",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "Other types of objects need to be converted -- either to a string (in text mode)",
    "example_code": "value = ('the answer', 42)\n\ns = str(value)  # convert the tuple to string\n\nf.write(s)\n\n18"
  },
  {
    "unit_id": "inputoutput.rst-28",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Methods of File Objects"
    ],
    "concept_text": "``f.tell()`` returns an integer giving the file object's current position in the file\nrepresented as number of bytes from the beginning of the file when in binary mode and\nan opaque number when in text mode.\n\nTo change the file object's position, use ``f.seek(offset, whence)``.  The position is computed\nfrom adding *offset* to a reference point; the reference point is selected by\nthe *whence* argument.  A *whence* value of 0 measures from the beginning\nof the file, 1 uses the current file position, and 2 uses the end of the file as\nthe reference point.  *whence* can be omitted and defaults to 0, using the",
    "example_code": "f = open('workfile', 'rb+')\n\nf.write(b'0123456789abcdef')\n\n16\n\nf.seek(5)      # Go to the 6th byte in the file\n\n5\n\nf.read(1)\n\nb'5'\n\nf.seek(-3, 2)  # Go to the 3rd byte before the end\n\n13\n\nf.read(1)\n\nb'd'"
  },
  {
    "unit_id": "inputoutput.rst-29",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "Strings can easily be written to and read from a file.  Numbers take a bit more\neffort, since the :meth:`~io.TextIOBase.read` method only returns strings, which will have to\nbe passed to a function like :func:`int`, which takes a string like ``'123'``\nand returns its numeric value 123.  When you want to save more complex data\ntypes like nested lists and dictionaries, parsing and serializing by hand\nbecomes complicated.\n\nRather than having users constantly writing and debugging code to save\ncomplicated data types to files, Python allows you to use the popular data\ninterchange format called `JSON (JavaScript Object Notation)\n<https://json.org>`_.  The standard module called :mod:`json` can take Python\ndata hierarchies, and convert them to string representations; this process is\ncalled :dfn:`serializing`.  Reconstructing the data from the string representation\nis called :dfn:`deserializing`.  Between serializing and deserializing, the\nstring representing the object may have been stored in a file or data, or\nsent over a network connection to some distant machine.",
    "example_code": "The JSON format is commonly used by modern applications to allow for data\n\nexchange.  Many programmers are already familiar with it, which makes\n\nit a good choice for interoperability."
  },
  {
    "unit_id": "inputoutput.rst-30",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "If you have an object ``x``, you can view its JSON string representation with a",
    "example_code": "import json\n\nx = [1, 'simple', 'list']\n\njson.dumps(x)\n\n'[1, \"simple\", \"list\"]'"
  },
  {
    "unit_id": "inputoutput.rst-31",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "Another variant of the :func:`~json.dumps` function, called :func:`~json.dump`,\nsimply serializes the object to a :term:`text file`.  So if ``f`` is a",
    "example_code": "json.dump(x, f)"
  },
  {
    "unit_id": "inputoutput.rst-32",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "To decode the object again, if ``f`` is a :term:`binary file` or",
    "example_code": "x = json.load(f)"
  },
  {
    "unit_id": "inputoutput.rst-33",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "",
    "example_code": "JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening\n\nJSON file as a :term:`text file` for both of reading and writing."
  },
  {
    "unit_id": "inputoutput.rst-34",
    "source_file": "inputoutput.rst",
    "topic_hierarchy": [
      "Reading and Writing Files",
      "Saving structured data with :mod:`json`"
    ],
    "concept_text": "This simple serialization technique can handle lists and dictionaries, but\nserializing arbitrary class instances in JSON requires a bit of extra effort.\nThe reference for the :mod:`json` module contains an explanation of this.",
    "example_code": ":mod:`pickle` - the pickle module\n\n\nContrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows\n\nthe serialization of arbitrarily complex Python objects.  As such, it is\n\nspecific to Python and cannot be used to communicate with applications\n\nwritten in other languages.  It is also insecure by default:\n\ndeserializing pickle data coming from an untrusted source can execute\n\narbitrary code, if the data was crafted by a skilled attacker."
  },
  {
    "unit_id": "errors.rst-0",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Syntax Errors"
    ],
    "concept_text": "Syntax errors, also known as parsing errors, are perhaps the most common kind of",
    "example_code": "while True print('Hello world')\n\n  File \"<stdin>\", line 1\n\n    while True print('Hello world')\n\n               ^^^^^\n\nSyntaxError: invalid syntax"
  },
  {
    "unit_id": "errors.rst-1",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Exceptions"
    ],
    "concept_text": "Even if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called *exceptions* and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by",
    "example_code": "10 * (1/0)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    10 * (1/0)\n\n          ~^~\n\nZeroDivisionError: division by zero\n\n4 + spam*3\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    4 + spam*3\n\n        ^^^^\n\nNameError: name 'spam' is not defined\n\n'2' + 2\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    '2' + 2\n\n    ~~~~^~~\n\nTypeError: can only concatenate str (not \"int\") to str"
  },
  {
    "unit_id": "errors.rst-2",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "It is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using :kbd:`Control-C` or\nwhatever the operating system supports); note that a user-generated interruption",
    "example_code": "while True:\n\n    try:\n\n        x = int(input(\"Please enter a number: \"))\n\n        break\n\n    except ValueError:\n\n        print(\"Oops!  That was no valid number.  Try again...\")\n\n..."
  },
  {
    "unit_id": "errors.rst-3",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "The :keyword:`try` statement works as follows.\n\n* First, the *try clause* (the statement(s) between the :keyword:`try` and\n:keyword:`except` keywords) is executed.\n\n* If no exception occurs, the *except clause* is skipped and execution of the\n:keyword:`try` statement is finished.\n\n* If an exception occurs during execution of the :keyword:`try` clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the\n:keyword:`except` keyword, the *except clause* is executed, and then execution\ncontinues after the try/except block.\n\n* If an exception occurs which does not match the exception named in the *except\nclause*, it is passed on to outer :keyword:`try` statements; if no handler is\nfound, it is an *unhandled exception* and execution stops with an error message.\n\nA :keyword:`try` statement may have more than one *except clause*, to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding *try clause*,\nnot in other handlers of the same :keyword:`!try` statement.  An *except clause*",
    "example_code": "except (RuntimeError, TypeError, NameError):\n\n    pass"
  },
  {
    "unit_id": "errors.rst-4",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "A class in an :keyword:`except` clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around --- an\n*except clause* listing a derived class does not match instances of its base classes).",
    "example_code": "class B(Exception):\n\n    pass\n\n\nclass C(B):\n\n    pass\n\n\nclass D(C):\n\n    pass\n\n\nfor cls in [B, C, D]:\n\n    try:\n\n        raise cls()\n\n    except D:\n\n        print(\"D\")\n\n    except C:\n\n        print(\"C\")\n\n    except B:\n\n        print(\"B\")"
  },
  {
    "unit_id": "errors.rst-5",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "Note that if the *except clauses* were reversed (with ``except B`` first), it\nwould have printed B, B, B --- the first matching *except clause* is triggered.\n\nWhen an exception occurs, it may have associated values, also known as the\nexception's *arguments*. The presence and types of the arguments depend on the\nexception type.\n\nThe *except clause* may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an ``args``\nattribute that stores the arguments. For convenience, builtin exception\ntypes define :meth:`~object.__str__` to print all the arguments without explicitly",
    "example_code": "try:\n\n    raise Exception('spam', 'eggs')\n\nexcept Exception as inst:\n\n    print(type(inst))    # the exception type\n\n    print(inst.args)     # arguments stored in .args\n\n    print(inst)          # __str__ allows args to be printed directly,\n\n    x, y = inst.args     # unpack args\n\n    print('x =', x)\n\n    print('y =', y)\n\n...\n\n<class 'Exception'>\n\n('spam', 'eggs')\n\n('spam', 'eggs')\n\nx = spam\n\ny = eggs"
  },
  {
    "unit_id": "errors.rst-6",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "The exception's :meth:`~object.__str__` output is printed as the last part ('detail')\nof the message for unhandled exceptions.\n\n:exc:`BaseException` is the common base class of all exceptions. One of its\nsubclasses, :exc:`Exception`, is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of :exc:`Exception` are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include :exc:`SystemExit` which is raised by :meth:`sys.exit` and\n:exc:`KeyboardInterrupt` which is raised when a user wishes to interrupt\nthe program.\n\n:exc:`Exception` can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\n\nThe most common pattern for handling :exc:`Exception` is to print or log\nthe exception and then re-raise it (allowing a caller to handle the",
    "example_code": "import sys\n\n\ntry:\n\n    f = open('myfile.txt')\n\n    s = f.readline()\n\n    i = int(s.strip())\n\nexcept OSError as err:\n\n    print(\"OS error:\", err)\n\nexcept ValueError:\n\n    print(\"Could not convert data to an integer.\")\n\nexcept Exception as err:\n\n    print(f\"Unexpected {err=}, {type(err)=}\")\n\n    raise"
  },
  {
    "unit_id": "errors.rst-7",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "The :keyword:`try` ... :keyword:`except` statement has an optional *else\nclause*, which, when present, must follow all *except clauses*.  It is useful\nfor code that must be executed if the *try clause* does not raise an exception.",
    "example_code": "for arg in sys.argv[1:]:\n\n    try:\n\n        f = open(arg, 'r')\n\n    except OSError:\n\n        print('cannot open', arg)\n\n    else:\n\n        print(arg, 'has', len(f.readlines()), 'lines')\n\n        f.close()"
  },
  {
    "unit_id": "errors.rst-8",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Handling Exceptions"
    ],
    "concept_text": "The use of the :keyword:`!else` clause is better than adding additional code to\nthe :keyword:`try` clause because it avoids accidentally catching an exception\nthat wasn't raised by the code being protected by the :keyword:`!try` ...\n:keyword:`!except` statement.\n\nException handlers do not handle only exceptions that occur immediately in the\n*try clause*, but also those that occur inside functions that are called (even",
    "example_code": "def this_fails():\n\n    x = 1/0\n\n...\n\ntry:\n\n    this_fails()\n\nexcept ZeroDivisionError as err:\n\n    print('Handling run-time error:', err)\n\n...\n\nHandling run-time error: division by zero"
  },
  {
    "unit_id": "errors.rst-9",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising Exceptions"
    ],
    "concept_text": "The :keyword:`raise` statement allows the programmer to force a specified",
    "example_code": "raise NameError('HiThere')\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    raise NameError('HiThere')\n\nNameError: HiThere"
  },
  {
    "unit_id": "errors.rst-10",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising Exceptions"
    ],
    "concept_text": "The sole argument to :keyword:`raise` indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from :class:`BaseException`, such as :exc:`Exception` or one of its\nsubclasses).  If an exception class is passed, it will be implicitly",
    "example_code": "raise ValueError  # shorthand for 'raise ValueError()'"
  },
  {
    "unit_id": "errors.rst-11",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising Exceptions"
    ],
    "concept_text": "If you need to determine whether an exception was raised but don't intend to\nhandle it, a simpler form of the :keyword:`raise` statement allows you to",
    "example_code": "try:\n\n    raise NameError('HiThere')\n\nexcept NameError:\n\n    print('An exception flew by!')\n\n    raise\n\n...\n\nAn exception flew by!\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 2, in <module>\n\n    raise NameError('HiThere')\n\nNameError: HiThere"
  },
  {
    "unit_id": "errors.rst-12",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Exception Chaining"
    ],
    "concept_text": "If an unhandled exception occurs inside an :keyword:`except` section, it will\nhave the exception being handled attached to it and included in the error",
    "example_code": "try:\n\n    open(\"database.sqlite\")\n\nexcept OSError:\n\n    raise RuntimeError(\"unable to handle error\")\n\n...\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 2, in <module>\n\n    open(\"database.sqlite\")\n\n    ~~~~^^^^^^^^^^^^^^^^^^^\n\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 4, in <module>\n\n    raise RuntimeError(\"unable to handle error\")\n\nRuntimeError: unable to handle error"
  },
  {
    "unit_id": "errors.rst-13",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Exception Chaining"
    ],
    "concept_text": "To indicate that an exception is a direct consequence of another, the",
    "example_code": "raise RuntimeError from exc"
  },
  {
    "unit_id": "errors.rst-14",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Exception Chaining"
    ],
    "concept_text": "",
    "example_code": "def func():\n\n    raise ConnectionError\n\n...\n\ntry:\n\n    func()\n\nexcept ConnectionError as exc:\n\n    raise RuntimeError('Failed to open database') from exc\n\n...\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 2, in <module>\n\n    func()\n\n    ~~~~^^\n\n  File \"<stdin>\", line 2, in func\n\nConnectionError\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 4, in <module>\n\n    raise RuntimeError('Failed to open database') from exc\n\nRuntimeError: Failed to open database"
  },
  {
    "unit_id": "errors.rst-15",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Exception Chaining"
    ],
    "concept_text": "It also allows disabling automatic exception chaining using the ``from None``",
    "example_code": "try:\n\n    open('database.sqlite')\n\nexcept OSError:\n\n    raise RuntimeError from None\n\n...\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 4, in <module>\n\n    raise RuntimeError from None\n\nRuntimeError"
  },
  {
    "unit_id": "errors.rst-16",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Defining Clean-up Actions"
    ],
    "concept_text": "The :keyword:`try` statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For",
    "example_code": "try:\n\n    raise KeyboardInterrupt\n\nfinally:\n\n    print('Goodbye, world!')\n\n...\n\nGoodbye, world!\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 2, in <module>\n\n    raise KeyboardInterrupt\n\nKeyboardInterrupt"
  },
  {
    "unit_id": "errors.rst-17",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Defining Clean-up Actions"
    ],
    "concept_text": "If a :keyword:`finally` clause is present, the :keyword:`!finally`\nclause will execute as the last task before the :keyword:`try`\nstatement completes. The :keyword:`!finally` clause runs whether or\nnot the :keyword:`!try` statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\n\n* If an exception occurs during execution of the :keyword:`!try`\nclause, the exception may be handled by an :keyword:`except`\nclause. If the exception is not handled by an :keyword:`!except`\nclause, the exception is re-raised after the :keyword:`!finally`\nclause has been executed.\n\n* An exception could occur during execution of an :keyword:`!except`\nor :keyword:`!else` clause. Again, the exception is re-raised after\nthe :keyword:`!finally` clause has been executed.\n\n* If the :keyword:`!finally` clause executes a :keyword:`break`,\n:keyword:`continue` or :keyword:`return` statement, exceptions are not\nre-raised. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a :exc:`SyntaxWarning` for it\n(see :pep:`765`).\n\n* If the :keyword:`!try` statement reaches a :keyword:`break`,\n:keyword:`continue` or :keyword:`return` statement, the\n:keyword:`!finally` clause will execute just prior to the\n:keyword:`!break`, :keyword:`!continue` or :keyword:`!return`\nstatement's execution.\n\n* If a :keyword:`!finally` clause includes a :keyword:`!return`\nstatement, the returned value will be the one from the\n:keyword:`!finally` clause's :keyword:`!return` statement, not the\nvalue from the :keyword:`!try` clause's :keyword:`!return`\nstatement. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a :exc:`SyntaxWarning` for it\n(see :pep:`765`).",
    "example_code": "def bool_return():\n\n    try:\n\n        return True\n\n    finally:\n\n        return False\n\n...\n\nbool_return()\n\nFalse"
  },
  {
    "unit_id": "errors.rst-18",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Defining Clean-up Actions"
    ],
    "concept_text": "",
    "example_code": "def divide(x, y):\n\n    try:\n\n        result = x / y\n\n    except ZeroDivisionError:\n\n        print(\"division by zero!\")\n\n    else:\n\n        print(\"result is\", result)\n\n    finally:\n\n        print(\"executing finally clause\")\n\n...\n\ndivide(2, 1)\n\nresult is 2.0\n\nexecuting finally clause\n\ndivide(2, 0)\n\ndivision by zero!\n\nexecuting finally clause\n\ndivide(\"2\", \"1\")\n\nexecuting finally clause\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    divide(\"2\", \"1\")\n\n    ~~~~~~^^^^^^^^^^\n\n  File \"<stdin>\", line 3, in divide\n\n    result = x / y\n\n             ~~^~~\n\nTypeError: unsupported operand type(s) for /: 'str' and 'str'"
  },
  {
    "unit_id": "errors.rst-19",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Predefined Clean-up Actions"
    ],
    "concept_text": "Some objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file",
    "example_code": "for line in open(\"myfile.txt\"):\n\n    print(line, end=\"\")"
  },
  {
    "unit_id": "errors.rst-20",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Predefined Clean-up Actions"
    ],
    "concept_text": "The problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The :keyword:`with` statement allows objects like files to be",
    "example_code": "with open(\"myfile.txt\") as f:\n\n    for line in f:\n\n        print(line, end=\"\")"
  },
  {
    "unit_id": "errors.rst-21",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising and Handling Multiple Unrelated Exceptions"
    ],
    "concept_text": "There are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\n\nThe builtin :exc:`ExceptionGroup` wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be",
    "example_code": "def f():\n\n    excs = [OSError('error 1'), SystemError('error 2')]\n\n    raise ExceptionGroup('there were problems', excs)\n\n...\n\nf()\n\n  + Exception Group Traceback (most recent call last):\n\n  |   File \"<stdin>\", line 1, in <module>\n\n  |     f()\n\n  |     ~^^\n\n  |   File \"<stdin>\", line 3, in f\n\n  |     raise ExceptionGroup('there were problems', excs)\n\n  | ExceptionGroup: there were problems (2 sub-exceptions)\n\n  +-+---------------- 1 ----------------\n\n    | OSError: error 1\n\n    +---------------- 2 ----------------\n\n    | SystemError: error 2\n\n    +------------------------------------\n\ntry:\n\n    f()\n\nexcept Exception as e:\n\n    print(f'caught {type(e)}: e')\n\n...\n\ncaught <class 'ExceptionGroup'>: e\n\n>>>"
  },
  {
    "unit_id": "errors.rst-22",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising and Handling Multiple Unrelated Exceptions"
    ],
    "concept_text": "By using ``except*`` instead of ``except``, we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each ``except*`` clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to",
    "example_code": "def f():\n\n    raise ExceptionGroup(\n\n        \"group1\",\n\n        [\n\n            OSError(1),\n\n            SystemError(2),\n\n            ExceptionGroup(\n\n                \"group2\",\n\n                [\n\n                    OSError(3),\n\n                    RecursionError(4)\n\n                ]\n\n            )\n\n        ]\n\n    )\n\n...\n\ntry:\n\n    f()\n\nexcept* OSError as e:\n\n    print(\"There were OSErrors\")\n\nexcept* SystemError as e:\n\n    print(\"There were SystemErrors\")\n\n...\n\nThere were OSErrors\n\nThere were SystemErrors\n\n  + Exception Group Traceback (most recent call last):\n\n  |   File \"<stdin>\", line 2, in <module>\n\n  |     f()\n\n  |     ~^^\n\n  |   File \"<stdin>\", line 2, in f\n\n  |     raise ExceptionGroup(\n\n  |     ...<12 lines>...\n\n  |     )\n\n  | ExceptionGroup: group1 (1 sub-exception)\n\n  +-+---------------- 1 ----------------\n\n    | ExceptionGroup: group2 (1 sub-exception)\n\n    +-+---------------- 1 ----------------\n\n      | RecursionError: 4\n\n      +------------------------------------\n\n>>>"
  },
  {
    "unit_id": "errors.rst-23",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Raising and Handling Multiple Unrelated Exceptions"
    ],
    "concept_text": "Note that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along",
    "example_code": "excs = []\n\nfor test in tests:\n\n    try:\n\n        test.run()\n\n    except Exception as e:\n\n        excs.append(e)\n\n...\n\nif excs:\n\n   raise ExceptionGroup(\"Test Failures\", excs)\n\n..."
  },
  {
    "unit_id": "errors.rst-24",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Enriching Exceptions with Notes"
    ],
    "concept_text": "When an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method ``add_note(note)`` that accepts a string and\nadds it to the exception's notes list. The standard traceback rendering",
    "example_code": "try:\n\n    raise TypeError('bad type')\n\nexcept Exception as e:\n\n    e.add_note('Add some information')\n\n    e.add_note('Add some more information')\n\n    raise\n\n...\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 2, in <module>\n\n    raise TypeError('bad type')\n\nTypeError: bad type\n\nAdd some information\n\nAdd some more information\n\n>>>"
  },
  {
    "unit_id": "errors.rst-25",
    "source_file": "errors.rst",
    "topic_hierarchy": [
      "Enriching Exceptions with Notes"
    ],
    "concept_text": "For example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each",
    "example_code": "def f():\n\n    raise OSError('operation failed')\n\n...\n\nexcs = []\n\nfor i in range(3):\n\n    try:\n\n        f()\n\n    except Exception as e:\n\n        e.add_note(f'Happened in Iteration {i+1}')\n\n        excs.append(e)\n\n...\n\nraise ExceptionGroup('We have some problems', excs)\n\n  + Exception Group Traceback (most recent call last):\n\n  |   File \"<stdin>\", line 1, in <module>\n\n  |     raise ExceptionGroup('We have some problems', excs)\n\n  | ExceptionGroup: We have some problems (3 sub-exceptions)\n\n  +-+---------------- 1 ----------------\n\n    | Traceback (most recent call last):\n\n    |   File \"<stdin>\", line 3, in <module>\n\n    |     f()\n\n    |     ~^^\n\n    |   File \"<stdin>\", line 2, in f\n\n    |     raise OSError('operation failed')\n\n    | OSError: operation failed\n\n    | Happened in Iteration 1\n\n    +---------------- 2 ----------------\n\n    | Traceback (most recent call last):\n\n    |   File \"<stdin>\", line 3, in <module>\n\n    |     f()\n\n    |     ~^^\n\n    |   File \"<stdin>\", line 2, in f\n\n    |     raise OSError('operation failed')\n\n    | OSError: operation failed\n\n    | Happened in Iteration 2\n\n    +---------------- 3 ----------------\n\n    | Traceback (most recent call last):\n\n    |   File \"<stdin>\", line 3, in <module>\n\n    |     f()\n\n    |     ~^^\n\n    |   File \"<stdin>\", line 2, in f\n\n    |     raise OSError('operation failed')\n\n    | OSError: operation failed\n\n    | Happened in Iteration 3\n\n    +------------------------------------\n\n>>>"
  },
  {
    "unit_id": "classes.rst-0",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Python Scopes and Namespaces",
      "Scopes and Namespaces Example"
    ],
    "concept_text": "This is an example demonstrating how to reference the different scopes and\nnamespaces, and how :keyword:`global` and :keyword:`nonlocal` affect variable",
    "example_code": "def scope_test():\n\n    def do_local():\n\n        spam = \"local spam\"\n\n\n    def do_nonlocal():\n\n        nonlocal spam\n\n        spam = \"nonlocal spam\"\n\n\n    def do_global():\n\n        global spam\n\n        spam = \"global spam\"\n\n\n    spam = \"test spam\"\n\n    do_local()\n\n    print(\"After local assignment:\", spam)\n\n    do_nonlocal()\n\n    print(\"After nonlocal assignment:\", spam)\n\n    do_global()\n\n    print(\"After global assignment:\", spam)\n\n\nscope_test()\n\nprint(\"In global scope:\", spam)"
  },
  {
    "unit_id": "classes.rst-1",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Definition Syntax"
    ],
    "concept_text": "",
    "example_code": "class ClassName:\n\n    <statement-1>\n\n    .\n\n    .\n\n    .\n\n    <statement-N>"
  },
  {
    "unit_id": "classes.rst-2",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Objects"
    ],
    "concept_text": "Class objects support two kinds of operations: attribute references and\ninstantiation.\n\n*Attribute references* use the standard syntax used for all attribute references\nin Python: ``obj.name``.  Valid attribute names are all the names that were in\nthe class's namespace when the class object was created.  So, if the class",
    "example_code": "class MyClass:\n\n    \"\"\"A simple example class\"\"\"\n\n    i = 12345\n\n\n    def f(self):\n\n        return 'hello world'"
  },
  {
    "unit_id": "classes.rst-3",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Objects"
    ],
    "concept_text": "then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of ``MyClass.i`` by assignment.\n:attr:`~type.__doc__` is also a valid attribute, returning the docstring\nbelonging to the class: ``\"A simple example class\"``.\n\nClass *instantiation* uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.",
    "example_code": "x = MyClass()"
  },
  {
    "unit_id": "classes.rst-4",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Objects"
    ],
    "concept_text": "creates a new *instance* of the class and assigns this object to the local\nvariable ``x``.\n\nThe instantiation operation (\"calling\" a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named",
    "example_code": "def __init__(self):\n\n    self.data = []"
  },
  {
    "unit_id": "classes.rst-5",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Objects"
    ],
    "concept_text": "When a class defines an :meth:`~object.__init__` method, class instantiation\nautomatically invokes :meth:`!__init__` for the newly created class instance.  So",
    "example_code": "x = MyClass()"
  },
  {
    "unit_id": "classes.rst-6",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class Objects"
    ],
    "concept_text": "Of course, the :meth:`~object.__init__` method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator",
    "example_code": "class Complex:\n\n    def __init__(self, realpart, imagpart):\n\n        self.r = realpart\n\n        self.i = imagpart\n\n...\n\nx = Complex(3.0, -4.5)\n\nx.r, x.i\n\n(3.0, -4.5)"
  },
  {
    "unit_id": "classes.rst-7",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Instance Objects"
    ],
    "concept_text": "Now what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\n\n*Data attributes* correspond to \"instance variables\" in Smalltalk, and to \"data\nmembers\" in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\n``x`` is the instance of :class:`!MyClass` created above, the following piece of",
    "example_code": "x.counter = 1\n\nwhile x.counter < 10:\n\n    x.counter = x.counter * 2\n\nprint(x.counter)\n\ndel x.counter"
  },
  {
    "unit_id": "classes.rst-8",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Method Objects"
    ],
    "concept_text": "",
    "example_code": "x.f()"
  },
  {
    "unit_id": "classes.rst-9",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Method Objects"
    ],
    "concept_text": "In the :class:`!MyClass` example, this will return the string ``'hello world'``.\nHowever, it is not necessary to call a method right away: ``x.f`` is a method",
    "example_code": "xf = x.f\n\nwhile True:\n\n    print(xf())"
  },
  {
    "unit_id": "classes.rst-10",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class and Instance Variables"
    ],
    "concept_text": "Generally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances",
    "example_code": "class Dog:\n\n\n    kind = 'canine'         # class variable shared by all instances\n\n\n    def __init__(self, name):\n\n        self.name = name    # instance variable unique to each instance\n\n\nd = Dog('Fido')\n\ne = Dog('Buddy')\n\nd.kind                  # shared by all dogs\n\n'canine'\n\ne.kind                  # shared by all dogs\n\n'canine'\n\nd.name                  # unique to d\n\n'Fido'\n\ne.name                  # unique to e\n\n'Buddy'"
  },
  {
    "unit_id": "classes.rst-11",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class and Instance Variables"
    ],
    "concept_text": "As discussed in :ref:`tut-object`, shared data can have possibly surprising\neffects with involving :term:`mutable` objects such as lists and dictionaries.\nFor example, the *tricks* list in the following code should not be used as a\nclass variable because just a single list would be shared by all *Dog*",
    "example_code": "class Dog:\n\n\n    tricks = []             # mistaken use of a class variable\n\n\n    def __init__(self, name):\n\n        self.name = name\n\n\n    def add_trick(self, trick):\n\n        self.tricks.append(trick)\n\n\nd = Dog('Fido')\n\ne = Dog('Buddy')\n\nd.add_trick('roll over')\n\ne.add_trick('play dead')\n\nd.tricks                # unexpectedly shared by all dogs\n\n['roll over', 'play dead']"
  },
  {
    "unit_id": "classes.rst-12",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "A First Look at Classes",
      "Class and Instance Variables"
    ],
    "concept_text": "",
    "example_code": "class Dog:\n\n\n    def __init__(self, name):\n\n        self.name = name\n\n        self.tricks = []    # creates a new empty list for each dog\n\n\n    def add_trick(self, trick):\n\n        self.tricks.append(trick)\n\n\nd = Dog('Fido')\n\ne = Dog('Buddy')\n\nd.add_trick('roll over')\n\ne.add_trick('play dead')\n\nd.tricks\n\n['roll over']\n\ne.tricks\n\n['play dead']"
  },
  {
    "unit_id": "classes.rst-13",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Random Remarks"
    ],
    "concept_text": "If the same attribute name occurs in both an instance and in a class,",
    "example_code": "class Warehouse:\n\n   purpose = 'storage'\n\n   region = 'west'\n\n...\n\nw1 = Warehouse()\n\nprint(w1.purpose, w1.region)\n\nstorage west\n\nw2 = Warehouse()\n\nw2.region = 'east'\n\nprint(w2.purpose, w2.region)\n\nstorage east"
  },
  {
    "unit_id": "classes.rst-14",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Random Remarks"
    ],
    "concept_text": "Data attributes may be referenced by methods as well as by ordinary users\n(\"clients\") of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding --- it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\n\nClients should use data attributes with care --- clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided ---\nagain, a naming convention can save a lot of headaches here.\n\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\n\nOften, the first argument of a method is called ``self``.  This is nothing more\nthan a convention: the name ``self`` has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a\n*class browser* program might be written that relies upon such a convention.\n\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local",
    "example_code": "def f1(self, x, y):\n\n    return min(x, x+y)\n\n\nclass C:\n\n    f = f1\n\n\n    def g(self):\n\n        return 'hello world'\n\n\n    h = g"
  },
  {
    "unit_id": "classes.rst-15",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Random Remarks"
    ],
    "concept_text": "Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that refer to\nfunction objects, and consequently they are all methods of instances of\n:class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note that this practice\nusually only serves to confuse the reader of a program.\n\nMethods may call other methods by using method attributes of the ``self``",
    "example_code": "class Bag:\n\n    def __init__(self):\n\n        self.data = []\n\n\n    def add(self, x):\n\n        self.data.append(x)\n\n\n    def addtwice(self, x):\n\n        self.add(x)\n\n        self.add(x)"
  },
  {
    "unit_id": "classes.rst-16",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Inheritance"
    ],
    "concept_text": "Of course, a language feature would not be worthy of the name \"class\" without\nsupporting inheritance.  The syntax for a derived class definition looks like",
    "example_code": "class DerivedClassName(BaseClassName):\n\n    <statement-1>\n\n    .\n\n    .\n\n    .\n\n    <statement-N>"
  },
  {
    "unit_id": "classes.rst-17",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Inheritance"
    ],
    "concept_text": "The name :class:`!BaseClassName` must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base",
    "example_code": "class DerivedClassName(modname.BaseClassName):"
  },
  {
    "unit_id": "classes.rst-18",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Inheritance",
      "Multiple Inheritance"
    ],
    "concept_text": "Python supports a form of multiple inheritance as well.  A class definition with",
    "example_code": "class DerivedClassName(Base1, Base2, Base3):\n\n    <statement-1>\n\n    .\n\n    .\n\n    .\n\n    <statement-N>"
  },
  {
    "unit_id": "classes.rst-19",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Private Variables"
    ],
    "concept_text": "\"Private\" instance variables that cannot be accessed except from inside an\nobject don't exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. ``_spam``) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.",
    "example_code": "pair: name; mangling"
  },
  {
    "unit_id": "classes.rst-20",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Private Variables"
    ],
    "concept_text": "Since there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called :dfn:`name mangling`.  Any identifier of the form\n``__spam`` (at least two leading underscores, at most one trailing underscore)\nis textually replaced with ``_classname__spam``, where ``classname`` is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.",
    "example_code": "The :ref:`private name mangling specifications <private-name-mangling>`\n\nfor details and special cases."
  },
  {
    "unit_id": "classes.rst-21",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Private Variables"
    ],
    "concept_text": "Name mangling is helpful for letting subclasses override methods without",
    "example_code": "class Mapping:\n\n    def __init__(self, iterable):\n\n        self.items_list = []\n\n        self.__update(iterable)\n\n\n    def update(self, iterable):\n\n        for item in iterable:\n\n            self.items_list.append(item)\n\n\n    __update = update   # private copy of original update() method\n\n\nclass MappingSubclass(Mapping):\n\n\n    def update(self, keys, values):\n\n        for item in zip(keys, values):\n\n            self.items_list.append(item)"
  },
  {
    "unit_id": "classes.rst-22",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Odds and Ends"
    ],
    "concept_text": "Sometimes it is useful to have a data type similar to the Pascal \"record\" or C\n\"struct\", bundling together a few named data items. The idiomatic approach",
    "example_code": "from dataclasses import dataclass\n\n\n@dataclass\n\nclass Employee:\n\n    name: str\n\n    dept: str\n\n    salary: int"
  },
  {
    "unit_id": "classes.rst-23",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Odds and Ends"
    ],
    "concept_text": "",
    "example_code": "john = Employee('john', 'computer lab', 1000)\n\njohn.dept\n\n'computer lab'\n\njohn.salary\n\n1000"
  },
  {
    "unit_id": "classes.rst-24",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Iterators"
    ],
    "concept_text": "By now you have probably noticed that most container objects can be looped over",
    "example_code": "for element in [1, 2, 3]:\n\n    print(element)\n\nfor element in (1, 2, 3):\n\n    print(element)\n\nfor key in {'one':1, 'two':2}:\n\n    print(key)\n\nfor char in \"123\":\n\n    print(char)\n\nfor line in open(\"myfile.txt\"):\n\n    print(line, end='')"
  },
  {
    "unit_id": "classes.rst-25",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Iterators"
    ],
    "concept_text": "This style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the :keyword:`for` statement\ncalls :func:`iter` on the container object.  The function returns an iterator\nobject that defines the method :meth:`~iterator.__next__` which accesses\nelements in the container one at a time.  When there are no more elements,\n:meth:`~iterator.__next__` raises a :exc:`StopIteration` exception which tells the\n:keyword:`!for` loop to terminate.  You can call the :meth:`~iterator.__next__` method",
    "example_code": "s = 'abc'\n\nit = iter(s)\n\nit\n\n<str_iterator object at 0x10c90e650>\n\nnext(it)\n\n'a'\n\nnext(it)\n\n'b'\n\nnext(it)\n\n'c'\n\nnext(it)\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    next(it)\n\nStopIteration"
  },
  {
    "unit_id": "classes.rst-26",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Iterators"
    ],
    "concept_text": "Having seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an :meth:`~container.__iter__` method which\nreturns an object with a :meth:`~iterator.__next__` method.  If the class",
    "example_code": "class Reverse:\n\n    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n\n    def __init__(self, data):\n\n        self.data = data\n\n        self.index = len(data)\n\n\n    def __iter__(self):\n\n        return self\n\n\n    def __next__(self):\n\n        if self.index == 0:\n\n            raise StopIteration\n\n        self.index = self.index - 1\n\n        return self.data[self.index]"
  },
  {
    "unit_id": "classes.rst-27",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Iterators"
    ],
    "concept_text": "",
    "example_code": "rev = Reverse('spam')\n\niter(rev)\n\n<__main__.Reverse object at 0x00A1DB50>\n\nfor char in rev:\n\n    print(char)\n\n...\n\nm\n\na\n\np\n\ns"
  },
  {
    "unit_id": "classes.rst-28",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Generators"
    ],
    "concept_text": ":term:`Generators <generator>` are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the :keyword:`yield` statement\nwhenever they want to return data.  Each time :func:`next` is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially",
    "example_code": "def reverse(data):\n\n    for index in range(len(data)-1, -1, -1):\n\n        yield data[index]"
  },
  {
    "unit_id": "classes.rst-29",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Generators"
    ],
    "concept_text": "",
    "example_code": "for char in reverse('golf'):\n\n    print(char)\n\n...\n\nf\n\nl\n\no\n\ng"
  },
  {
    "unit_id": "classes.rst-30",
    "source_file": "classes.rst",
    "topic_hierarchy": [
      "Generator Expressions"
    ],
    "concept_text": "Some simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.",
    "example_code": "sum(i*i for i in range(10))                 # sum of squares\n\n285\n\n\nxvec = [10, 20, 30]\n\nyvec = [7, 5, 3]\n\nsum(x*y for x,y in zip(xvec, yvec))         # dot product\n\n260\n\n\nunique_words = set(word for line in page  for word in line.split())\n\n\nvaledictorian = max((student.gpa, student.name) for student in graduates)\n\n\ndata = 'golf'\n\nlist(data[i] for i in range(len(data)-1, -1, -1))\n\n['f', 'l', 'o', 'g']"
  },
  {
    "unit_id": "stdlib.rst-0",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Operating System Interface"
    ],
    "concept_text": "The :mod:`os` module provides dozens of functions for interacting with the",
    "example_code": "import os\n\nos.getcwd()      # Return the current working directory\n\n'C:\\\\Python315'\n\nos.chdir('/server/accesslogs')   # Change current working directory\n\nos.system('mkdir today')   # Run the command mkdir in the system shell\n\n0"
  },
  {
    "unit_id": "stdlib.rst-1",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Operating System Interface"
    ],
    "concept_text": "Be sure to use the ``import os`` style instead of ``from os import *``.  This\nwill keep :func:`os.open` from shadowing the built-in :func:`open` function which\noperates much differently.\n\n\nThe built-in :func:`dir` and :func:`help` functions are useful as interactive",
    "example_code": "import os\n\ndir(os)\n\n<returns a list of all module functions>\n\nhelp(os)\n\n<returns an extensive manual page created from the module's docstrings>"
  },
  {
    "unit_id": "stdlib.rst-2",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Operating System Interface"
    ],
    "concept_text": "For daily file and directory management tasks, the :mod:`shutil` module provides",
    "example_code": "import shutil\n\nshutil.copyfile('data.db', 'archive.db')\n\n'archive.db'\n\nshutil.move('/build/executables', 'installdir')\n\n'installdir'"
  },
  {
    "unit_id": "stdlib.rst-3",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "File Wildcards"
    ],
    "concept_text": "The :mod:`glob` module provides a function for making file lists from directory",
    "example_code": "import glob\n\nglob.glob('*.py')\n\n['primes.py', 'random.py', 'quote.py']"
  },
  {
    "unit_id": "stdlib.rst-4",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Command Line Arguments"
    ],
    "concept_text": "Common utility scripts often need to process command line arguments. These\narguments are stored in the :mod:`sys` module's *argv* attribute as a list.  For",
    "example_code": "import sys\n\nprint(sys.argv)"
  },
  {
    "unit_id": "stdlib.rst-5",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Command Line Arguments"
    ],
    "concept_text": "Here is the output from running ``python demo.py one two three`` at the command",
    "example_code": "['demo.py', 'one', 'two', 'three']"
  },
  {
    "unit_id": "stdlib.rst-6",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Command Line Arguments"
    ],
    "concept_text": "The :mod:`argparse` module provides a more sophisticated mechanism to process\ncommand line arguments.  The following script extracts one or more filenames",
    "example_code": "import argparse\n\n\nparser = argparse.ArgumentParser(\n\n    prog='top',\n\n    description='Show top lines from each file')\n\nparser.add_argument('filenames', nargs='+')\n\nparser.add_argument('-l', '--lines', type=int, default=10)\n\nargs = parser.parse_args()\n\nprint(args)"
  },
  {
    "unit_id": "stdlib.rst-7",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Error Output Redirection and Program Termination"
    ],
    "concept_text": "The :mod:`sys` module also has attributes for *stdin*, *stdout*, and *stderr*.\nThe latter is useful for emitting warnings and error messages to make them",
    "example_code": "sys.stderr.write('Warning, log file not found starting a new one\\n')\n\nWarning, log file not found starting a new one"
  },
  {
    "unit_id": "stdlib.rst-8",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "String Pattern Matching"
    ],
    "concept_text": "The :mod:`re` module provides regular expression tools for advanced string\nprocessing. For complex matching and manipulation, regular expressions offer",
    "example_code": "import re\n\nre.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n\n['foot', 'fell', 'fastest']\n\nre.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n\n'cat in the hat'"
  },
  {
    "unit_id": "stdlib.rst-9",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "String Pattern Matching"
    ],
    "concept_text": "When only simple capabilities are needed, string methods are preferred because",
    "example_code": "'tea for too'.replace('too', 'two')\n\n'tea for two'"
  },
  {
    "unit_id": "stdlib.rst-10",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Mathematics"
    ],
    "concept_text": "The :mod:`math` module gives access to the underlying C library functions for",
    "example_code": "import math\n\nmath.cos(math.pi / 4)\n\n0.70710678118654757\n\nmath.log(1024, 2)\n\n10.0"
  },
  {
    "unit_id": "stdlib.rst-11",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Mathematics"
    ],
    "concept_text": "",
    "example_code": "import random\n\nrandom.choice(['apple', 'pear', 'banana'])\n\n'apple'\n\nrandom.sample(range(100), 10)   # sampling without replacement\n\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n\nrandom.random()    # random float from the interval [0.0, 1.0)\n\n0.17970987693706186\n\nrandom.randrange(6)    # random integer chosen from range(6)\n\n4"
  },
  {
    "unit_id": "stdlib.rst-12",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Mathematics"
    ],
    "concept_text": "The :mod:`statistics` module calculates basic statistical properties",
    "example_code": "import statistics\n\ndata = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n\nstatistics.mean(data)\n\n1.6071428571428572\n\nstatistics.median(data)\n\n1.25\n\nstatistics.variance(data)\n\n1.3720238095238095"
  },
  {
    "unit_id": "stdlib.rst-13",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Internet Access"
    ],
    "concept_text": "There are a number of modules for accessing the internet and processing internet\nprotocols. Two of the simplest are :mod:`urllib.request` for retrieving data",
    "example_code": "from urllib.request import urlopen\n\nwith urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response:\n\n    for line in response:\n\n        line = line.decode()             # Convert bytes to a str\n\n        if line.startswith('datetime'):\n\n            print(line.rstrip())         # Remove trailing newline\n\n...\n\ndatetime: 2022-01-01T01:36:47.689215+00:00\n\n\nimport smtplib\n\nserver = smtplib.SMTP('localhost')\n\nserver.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n\n\"\"\"To: jcaesar@example.org\n\nFrom: soothsayer@example.org\n\n...\n\nBeware the Ides of March.\n\n\"\"\")\n\nserver.quit()"
  },
  {
    "unit_id": "stdlib.rst-14",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Dates and Times"
    ],
    "concept_text": "The :mod:`datetime` module supplies classes for manipulating dates and times in\nboth simple and complex ways. While date and time arithmetic is supported, the\nfocus of the implementation is on efficient member extraction for output\nformatting and manipulation.  The module also supports objects that are timezone",
    "example_code": "from datetime import date\n\nnow = date.today()\n\nnow\n\ndatetime.date(2003, 12, 2)\n\nnow.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n\n\nbirthday = date(1964, 7, 31)\n\nage = now - birthday\n\nage.days\n\n14368"
  },
  {
    "unit_id": "stdlib.rst-15",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Data Compression"
    ],
    "concept_text": "Common data archiving and compression formats are directly supported by modules\nincluding: :mod:`zlib`, :mod:`gzip`, :mod:`bz2`, :mod:`lzma`, :mod:`zipfile` and",
    "example_code": "import zlib\n\ns = b'witch which has which witches wrist watch'\n\nlen(s)\n\n41\n\nt = zlib.compress(s)\n\nlen(t)\n\n37\n\nzlib.decompress(t)\n\nb'witch which has which witches wrist watch'\n\nzlib.crc32(s)\n\n226805979"
  },
  {
    "unit_id": "stdlib.rst-16",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Performance Measurement"
    ],
    "concept_text": "Some Python users develop a deep interest in knowing the relative performance of\ndifferent approaches to the same problem. Python provides a measurement tool\nthat answers those questions immediately.\n\nFor example, it may be tempting to use the tuple packing and unpacking feature\ninstead of the traditional approach to swapping arguments. The :mod:`timeit`",
    "example_code": "from timeit import Timer\n\nTimer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n\n0.57535828626024577\n\nTimer('a,b = b,a', 'a=1; b=2').timeit()\n\n0.54962537085770791"
  },
  {
    "unit_id": "stdlib.rst-17",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Quality Control"
    ],
    "concept_text": "One approach for developing high quality software is to write tests for each\nfunction as it is developed and to run those tests frequently during the\ndevelopment process.\n\nThe :mod:`doctest` module provides a tool for scanning a module and validating\ntests embedded in a program's docstrings.  Test construction is as simple as\ncutting-and-pasting a typical call along with its results into the docstring.\nThis improves the documentation by providing the user with an example and it\nallows the doctest module to make sure the code remains true to the",
    "example_code": "def average(values):\n\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n\nprint(average([20, 30, 70]))\n\n    40.0\n\n    \"\"\"\n\n    return sum(values) / len(values)\n\n\nimport doctest\n\ndoctest.testmod()   # automatically validate the embedded tests"
  },
  {
    "unit_id": "stdlib.rst-18",
    "source_file": "stdlib.rst",
    "topic_hierarchy": [
      "Quality Control"
    ],
    "concept_text": "The :mod:`unittest` module is not as effortless as the :mod:`doctest` module,\nbut it allows a more comprehensive set of tests to be maintained in a separate",
    "example_code": "import unittest\n\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n\n    def test_average(self):\n\n        self.assertEqual(average([20, 30, 70]), 40.0)\n\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n\n        with self.assertRaises(ZeroDivisionError):\n\n            average([])\n\n        with self.assertRaises(TypeError):\n\n            average(20, 30, 70)\n\n\nunittest.main()  # Calling from the command line invokes all tests"
  },
  {
    "unit_id": "stdlib2.rst-0",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Output Formatting"
    ],
    "concept_text": "The :mod:`reprlib` module provides a version of :func:`repr` customized for",
    "example_code": "import reprlib\n\nreprlib.repr(set('supercalifragilisticexpialidocious'))\n\n\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""
  },
  {
    "unit_id": "stdlib2.rst-1",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Output Formatting"
    ],
    "concept_text": "The :mod:`pprint` module offers more sophisticated control over printing both\nbuilt-in and user defined objects in a way that is readable by the interpreter.\nWhen the result is longer than one line, the \"pretty printer\" adds line breaks",
    "example_code": "import pprint\n\nt = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n\n    'yellow'], 'blue']]]\n\n...\n\npprint.pprint(t, width=30)\n\n[[[['black', 'cyan'],\n\n   'white',\n\n   ['green', 'red']],\n\n  [['magenta', 'yellow'],\n\n   'blue']]]"
  },
  {
    "unit_id": "stdlib2.rst-2",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Output Formatting"
    ],
    "concept_text": "The :mod:`textwrap` module formats paragraphs of text to fit a given screen",
    "example_code": "import textwrap\n\ndoc = \"\"\"The wrap() method is just like fill() except that it returns\n\na list of strings instead of one big string with newlines to separate\n\nthe wrapped lines.\"\"\"\n\n...\n\nprint(textwrap.fill(doc, width=40))\n\nThe wrap() method is just like fill()\n\nexcept that it returns a list of strings\n\ninstead of one big string with newlines\n\nto separate the wrapped lines."
  },
  {
    "unit_id": "stdlib2.rst-3",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Output Formatting"
    ],
    "concept_text": "The :mod:`locale` module accesses a database of culture specific data formats.\nThe grouping attribute of locale's format function provides a direct way of",
    "example_code": "import locale\n\nlocale.setlocale(locale.LC_ALL, 'English_United States.1252')\n\n'English_United States.1252'\n\nconv = locale.localeconv()          # get a mapping of conventions\n\nx = 1234567.8\n\nlocale.format_string(\"%d\", x, grouping=True)\n\n'1,234,567'\n\nlocale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n\n                     conv['frac_digits'], x), grouping=True)\n\n'$1,234,567.80'"
  },
  {
    "unit_id": "stdlib2.rst-4",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Templating"
    ],
    "concept_text": "The :mod:`string` module includes a versatile :class:`~string.Template` class\nwith a simplified syntax suitable for editing by end-users.  This allows users\nto customize their applications without having to alter the application.\n\nThe format uses placeholder names formed by ``$`` with valid Python identifiers\n(alphanumeric characters and underscores).  Surrounding the placeholder with\nbraces allows it to be followed by more alphanumeric letters with no intervening",
    "example_code": "from string import Template\n\nt = Template('${village}folk send $$10 to $cause.')\n\nt.substitute(village='Nottingham', cause='the ditch fund')\n\n'Nottinghamfolk send $10 to the ditch fund.'"
  },
  {
    "unit_id": "stdlib2.rst-5",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Templating"
    ],
    "concept_text": "The :meth:`~string.Template.substitute` method raises a :exc:`KeyError` when a\nplaceholder is not supplied in a dictionary or a keyword argument.  For\nmail-merge style applications, user supplied data may be incomplete and the\n:meth:`~string.Template.safe_substitute` method may be more appropriate ---",
    "example_code": "t = Template('Return the $item to $owner.')\n\nd = dict(item='unladen swallow')\n\nt.substitute(d)\n\nTraceback (most recent call last):\n\n  ...\n\nKeyError: 'owner'\n\nt.safe_substitute(d)\n\n'Return the unladen swallow to $owner.'"
  },
  {
    "unit_id": "stdlib2.rst-6",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Templating"
    ],
    "concept_text": "Template subclasses can specify a custom delimiter.  For example, a batch\nrenaming utility for a photo browser may elect to use percent signs for",
    "example_code": "import time, os.path\n\nphotofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n\nclass BatchRename(Template):\n\n    delimiter = '%'\n\n...\n\nfmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')\n\nEnter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n\n\nt = BatchRename(fmt)\n\ndate = time.strftime('%d%b%y')\n\nfor i, filename in enumerate(photofiles):\n\n    base, ext = os.path.splitext(filename)\n\n    newname = t.substitute(d=date, n=i, f=ext)\n\n    print('{0} --> {1}'.format(filename, newname))\n\n\nimg_1074.jpg --> Ashley_0.jpg\n\nimg_1076.jpg --> Ashley_1.jpg\n\nimg_1077.jpg --> Ashley_2.jpg"
  },
  {
    "unit_id": "stdlib2.rst-7",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Working with Binary Data Record Layouts"
    ],
    "concept_text": "The :mod:`struct` module provides :func:`~struct.pack` and\n:func:`~struct.unpack` functions for working with variable length binary\nrecord formats.  The following example shows\nhow to loop through header information in a ZIP file without using the\n:mod:`zipfile` module.  Pack codes ``\"H\"`` and ``\"I\"`` represent two and four\nbyte unsigned numbers respectively.  The ``\"<\"`` indicates that they are",
    "example_code": "import struct\n\n\nwith open('myfile.zip', 'rb') as f:\n\n    data = f.read()\n\n\nstart = 0\n\nfor i in range(3):                      # show the first 3 file headers\n\n    start += 14\n\n    fields = struct.unpack('<IIIHH', data[start:start+16])\n\n    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n\n\n    start += 16\n\n    filename = data[start:start+filenamesize]\n\n    start += filenamesize\n\n    extra = data[start:start+extra_size]\n\n    print(filename, hex(crc32), comp_size, uncomp_size)\n\n\n    start += extra_size + comp_size     # skip to the next header"
  },
  {
    "unit_id": "stdlib2.rst-8",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Multi-threading"
    ],
    "concept_text": "Threading is a technique for decoupling tasks which are not sequentially\ndependent.  Threads can be used to improve the responsiveness of applications\nthat accept user input while other tasks run in the background.  A related use\ncase is running I/O in parallel with computations in another thread.\n\nThe following code shows how the high level :mod:`threading` module can run",
    "example_code": "import threading, zipfile\n\n\nclass AsyncZip(threading.Thread):\n\n    def __init__(self, infile, outfile):\n\n        threading.Thread.__init__(self)\n\n        self.infile = infile\n\n        self.outfile = outfile\n\n\n    def run(self):\n\n        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n\n        f.write(self.infile)\n\n        f.close()\n\n        print('Finished background zip of:', self.infile)\n\n\nbackground = AsyncZip('mydata.txt', 'myarchive.zip')\n\nbackground.start()\n\nprint('The main program continues to run in foreground.')\n\n\nbackground.join()    # Wait for the background task to finish\n\nprint('Main program waited until background was done.')"
  },
  {
    "unit_id": "stdlib2.rst-9",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Logging"
    ],
    "concept_text": "The :mod:`logging` module offers a full featured and flexible logging system.",
    "example_code": "import logging\n\nlogging.debug('Debugging information')\n\nlogging.info('Informational message')\n\nlogging.warning('Warning:config file %s not found', 'server.conf')\n\nlogging.error('Error occurred')\n\nlogging.critical('Critical error -- shutting down')"
  },
  {
    "unit_id": "stdlib2.rst-10",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Weak References"
    ],
    "concept_text": "Python does automatic memory management (reference counting for most objects and\n:term:`garbage collection` to eliminate cycles).  The memory is freed shortly\nafter the last reference to it has been eliminated.\n\nThis approach works fine for most applications but occasionally there is a need\nto track objects only as long as they are being used by something else.\nUnfortunately, just tracking them creates a reference that makes them permanent.\nThe :mod:`weakref` module provides tools for tracking objects without creating a\nreference.  When the object is no longer needed, it is automatically removed\nfrom a weakref table and a callback is triggered for weakref objects.  Typical",
    "example_code": "import weakref, gc\n\nclass A:\n\n    def __init__(self, value):\n\n        self.value = value\n\n    def __repr__(self):\n\n        return str(self.value)\n\n...\n\na = A(10)                   # create a reference\n\nd = weakref.WeakValueDictionary()\n\nd['primary'] = a            # does not create a reference\n\nd['primary']                # fetch the object if it is still alive\n\n10\n\ndel a                       # remove the one reference\n\ngc.collect()                # run garbage collection right away\n\n0\n\nd['primary']                # entry was automatically removed\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\n    d['primary']                # entry was automatically removed\n\n  File \"C:/python315/lib/weakref.py\", line 46, in __getitem__\n\n    o = self.data[key]()\n\nKeyError: 'primary'"
  },
  {
    "unit_id": "stdlib2.rst-11",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Tools for Working with Lists"
    ],
    "concept_text": "Many data structure needs can be met with the built-in list type. However,\nsometimes there is a need for alternative implementations with different\nperformance trade-offs.\n\nThe :mod:`array` module provides an :class:`~array.array` object that is like\na list that stores only homogeneous data and stores it more compactly.  The\nfollowing example shows an array of numbers stored as two byte unsigned binary\nnumbers (typecode ``\"H\"``) rather than the usual 16 bytes per entry for regular",
    "example_code": "from array import array\n\na = array('H', [4000, 10, 700, 22222])\n\nsum(a)\n\n26932\n\na[1:3]\n\narray('H', [10, 700])"
  },
  {
    "unit_id": "stdlib2.rst-12",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Tools for Working with Lists"
    ],
    "concept_text": "The :mod:`collections` module provides a :class:`~collections.deque` object\nthat is like a list with faster appends and pops from the left side but slower\nlookups in the middle. These objects are well suited for implementing queues",
    "example_code": "from collections import deque\n\nd = deque([\"task1\", \"task2\", \"task3\"])\n\nd.append(\"task4\")\n\nprint(\"Handling\", d.popleft())\n\nHandling task1"
  },
  {
    "unit_id": "stdlib2.rst-13",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Tools for Working with Lists"
    ],
    "concept_text": "",
    "example_code": "unsearched = deque([starting_node])\n\ndef breadth_first_search(unsearched):\n\n    node = unsearched.popleft()\n\n    for m in gen_moves(node):\n\n        if is_goal(m):\n\n            return m\n\n        unsearched.append(m)"
  },
  {
    "unit_id": "stdlib2.rst-14",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Tools for Working with Lists"
    ],
    "concept_text": "In addition to alternative list implementations, the library also offers other\ntools such as the :mod:`bisect` module with functions for manipulating sorted",
    "example_code": "import bisect\n\nscores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n\nbisect.insort(scores, (300, 'ruby'))\n\nscores\n\n[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]"
  },
  {
    "unit_id": "stdlib2.rst-15",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Tools for Working with Lists"
    ],
    "concept_text": "The :mod:`heapq` module provides functions for implementing heaps based on\nregular lists.  The lowest valued entry is always kept at position zero.  This\nis useful for applications which repeatedly access the smallest element but do",
    "example_code": "from heapq import heapify, heappop, heappush\n\ndata = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n\nheapify(data)                      # rearrange the list into heap order\n\nheappush(data, -5)                 # add a new entry\n\n[heappop(data) for i in range(3)]  # fetch the three smallest entries\n\n[-5, 0, 1]"
  },
  {
    "unit_id": "stdlib2.rst-16",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Decimal Floating-Point Arithmetic"
    ],
    "concept_text": "The :mod:`decimal` module offers a :class:`~decimal.Decimal` datatype for\ndecimal floating-point arithmetic.  Compared to the built-in :class:`float`\nimplementation of binary floating point, the class is especially helpful for\n\n* financial applications and other uses which require exact decimal\nrepresentation,\n* control over precision,\n* control over rounding to meet legal or regulatory requirements,\n* tracking of significant decimal places, or\n* applications where the user expects the results to match calculations done by\nhand.\n\nFor example, calculating a 5% tax on a 70 cent phone charge gives different\nresults in decimal floating point and binary floating point. The difference",
    "example_code": "from decimal import *\n\nround(Decimal('0.70') * Decimal('1.05'), 2)\n\nDecimal('0.74')\n\nround(.70 * 1.05, 2)\n\n0.73"
  },
  {
    "unit_id": "stdlib2.rst-17",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Decimal Floating-Point Arithmetic"
    ],
    "concept_text": "The :class:`~decimal.Decimal` result keeps a trailing zero, automatically\ninferring four place significance from multiplicands with two place\nsignificance.  Decimal reproduces mathematics as done by hand and avoids\nissues that can arise when binary floating point cannot exactly represent\ndecimal quantities.\n\nExact representation enables the :class:`~decimal.Decimal` class to perform\nmodulo calculations and equality tests that are unsuitable for binary floating",
    "example_code": "Decimal('1.00') % Decimal('.10')\n\nDecimal('0.00')\n\n1.00 % 0.10\n\n0.09999999999999995\n\n\nsum([Decimal('0.1')]*10) == Decimal('1.0')\n\nTrue\n\n0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n\nFalse"
  },
  {
    "unit_id": "stdlib2.rst-18",
    "source_file": "stdlib2.rst",
    "topic_hierarchy": [
      "Decimal Floating-Point Arithmetic"
    ],
    "concept_text": "",
    "example_code": "getcontext().prec = 36\n\nDecimal(1) / Decimal(7)\n\nDecimal('0.142857142857142857142857142857142857')"
  },
  {
    "unit_id": "venv.rst-0",
    "source_file": "venv.rst",
    "topic_hierarchy": [
      "Creating Virtual Environments"
    ],
    "concept_text": "The module used to create and manage virtual environments is called\n:mod:`venv`.  :mod:`venv` will install the Python version from which\nthe command was run (as reported by the :option:`--version` option).\nFor instance, executing the command with ``python3.12`` will install\nversion 3.12.\n\nTo create a virtual environment, decide upon a directory where you want to",
    "example_code": "python -m venv tutorial-env"
  },
  {
    "unit_id": "venv.rst-1",
    "source_file": "venv.rst",
    "topic_hierarchy": [
      "Creating Virtual Environments"
    ],
    "concept_text": "This will create the ``tutorial-env`` directory if it doesn't exist,\nand also create directories inside it containing a copy of the Python\ninterpreter and various supporting files.\n\nA common directory location for a virtual environment is ``.venv``.\nThis name keeps the directory typically hidden in your shell and thus\nout of the way while giving it a name that explains why the directory\nexists. It also prevents clashing with ``.env`` environment variable\ndefinition files that some tooling supports.\n\nOnce you've created a virtual environment, you may activate it.",
    "example_code": "tutorial-env\\Scripts\\activate"
  },
  {
    "unit_id": "venv.rst-2",
    "source_file": "venv.rst",
    "topic_hierarchy": [
      "Creating Virtual Environments"
    ],
    "concept_text": "",
    "example_code": "source tutorial-env/bin/activate"
  },
  {
    "unit_id": "venv.rst-3",
    "source_file": "venv.rst",
    "topic_hierarchy": [
      "Creating Virtual Environments"
    ],
    "concept_text": "(This script is written for the bash shell.  If you use the\n:program:`csh` or :program:`fish` shells, there are alternate\n``activate.csh`` and ``activate.fish`` scripts you should use\ninstead.)\n\nActivating the virtual environment will change your shell's prompt to show what\nvirtual environment you're using, and modify the environment so that running\n``python`` will get you that particular version and installation of Python.\nFor example:\n\n\n$ source ~/envs/tutorial-env/bin/activate\n(tutorial-env) $ python\nPython 3.5.1 (default, May  6 2016, 10:59:36)\n>>> import sys\n>>> sys.path\n['', '/usr/local/lib/python35.zip', ...,\n'~/envs/tutorial-env/lib/python3.5/site-packages']\n>>>",
    "example_code": "deactivate"
  },
  {
    "unit_id": "floatingpoint.rst-0",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "",
    "example_code": "import math\n\nfrom fractions import Fraction"
  },
  {
    "unit_id": "floatingpoint.rst-1",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "**************************************************\nFloating-Point Arithmetic:  Issues and Limitations\n**************************************************\n\n\n\nFloating-point numbers are represented in computer hardware as base 2 (binary)\nfractions.  For example, the **decimal** fraction ``0.625``\nhas value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction ``0.101``\nhas value 1/2 + 0/4 + 1/8. These two fractions have identical values, the only\nreal difference being that the first is written in base 10 fractional notation,\nand the second in base 2.\n\nUnfortunately, most decimal fractions cannot be represented exactly as binary\nfractions.  A consequence is that, in general, the decimal floating-point\nnumbers you enter are only approximated by the binary floating-point numbers\nactually stored in the machine.\n\nThe problem is easier to understand at first in base 10.  Consider the fraction",
    "example_code": "0.3"
  },
  {
    "unit_id": "floatingpoint.rst-2",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "",
    "example_code": "0.33"
  },
  {
    "unit_id": "floatingpoint.rst-3",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "",
    "example_code": "0.333"
  },
  {
    "unit_id": "floatingpoint.rst-4",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "and so on.  No matter how many digits you're willing to write down, the result\nwill never be exactly 1/3, but will be an increasingly better approximation of\n1/3.\n\nIn the same way, no matter how many base 2 digits you're willing to use, the\ndecimal value 0.1 cannot be represented exactly as a base 2 fraction.  In base",
    "example_code": "0.0001100110011001100110011001100110011001100110011..."
  },
  {
    "unit_id": "floatingpoint.rst-5",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Stop at any finite number of bits, and you get an approximation.  On most\nmachines today, floats are approximated using a binary fraction with\nthe numerator using the first 53 bits starting with the most significant bit and\nwith the denominator as a power of two.  In the case of 1/10, the binary fraction\nis ``3602879701896397 / 2 ** 55`` which is close to but not exactly\nequal to the true value of 1/10.\n\nMany users are not aware of the approximation because of the way values are\ndisplayed.  Python only prints a decimal approximation to the true decimal\nvalue of the binary approximation stored by the machine.  On most machines, if\nPython were to print the true decimal value of the binary approximation stored",
    "example_code": "0.1\n\n0.1000000000000000055511151231257827021181583404541015625"
  },
  {
    "unit_id": "floatingpoint.rst-6",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "That is more digits than most people find useful, so Python keeps the number\nof digits manageable by displaying a rounded value instead:",
    "example_code": "1 / 10\n\n0.1"
  },
  {
    "unit_id": "floatingpoint.rst-7",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Just remember, even though the printed result looks like the exact value\nof 1/10, the actual stored value is the nearest representable binary fraction.\n\nInterestingly, there are many different decimal numbers that share the same\nnearest approximate binary fraction.  For example, the numbers ``0.1`` and\n``0.10000000000000001`` and\n``0.1000000000000000055511151231257827021181583404541015625`` are all\napproximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal\nvalues share the same approximation, any one of them could be displayed\nwhile still preserving the invariant ``eval(repr(x)) == x``.\n\nHistorically, the Python prompt and built-in :func:`repr` function would choose\nthe one with 17 significant digits, ``0.10000000000000001``.   Starting with\nPython 3.1, Python (on most systems) is now able to choose the shortest of\nthese and simply display ``0.1``.\n\nNote that this is in the very nature of binary floating point: this is not a bug\nin Python, and it is not a bug in your code either.  You'll see the same kind of\nthing in all languages that support your hardware's floating-point arithmetic\n(although some languages may not *display* the difference by default, or in all\noutput modes).\n\nFor more pleasant output, you may wish to use string formatting to produce a\nlimited number of significant digits:",
    "example_code": "format(math.pi, '.12g')  # give 12 significant digits\n\n'3.14159265359'\n\n\nformat(math.pi, '.2f')   # give 2 digits after the point\n\n'3.14'\n\n\nrepr(math.pi)\n\n'3.141592653589793'"
  },
  {
    "unit_id": "floatingpoint.rst-8",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "It's important to realize that this is, in a real sense, an illusion: you're\nsimply rounding the *display* of the true machine value.\n\nOne illusion may beget another.  For example, since 0.1 is not exactly 1/10,\nsumming three values of 0.1 may not yield exactly 0.3, either:",
    "example_code": "0.1 + 0.1 + 0.1 == 0.3\n\nFalse"
  },
  {
    "unit_id": "floatingpoint.rst-9",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Also, since the 0.1 cannot get any closer to the exact value of 1/10 and\n0.3 cannot get any closer to the exact value of 3/10, then pre-rounding with\n:func:`round` function cannot help:",
    "example_code": "round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n\nFalse"
  },
  {
    "unit_id": "floatingpoint.rst-10",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Though the numbers cannot be made closer to their intended exact values,\nthe :func:`math.isclose` function can be useful for comparing inexact values:",
    "example_code": "math.isclose(0.1 + 0.1 + 0.1, 0.3)\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-11",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Alternatively, the :func:`round` function can be used to compare rough\napproximations:",
    "example_code": "round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-12",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Binary floating-point arithmetic holds many surprises like this.  The problem\nwith \"0.1\" is explained in precise detail below, in the \"Representation Error\"\nsection.  See `Examples of Floating Point Problems\n<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ for\na pleasant summary of how binary floating point works and the kinds of\nproblems commonly encountered in practice.  Also see\n`The Perils of Floating Point <http://www.indowsway.com/floatingpoint.htm>`_\nfor a more complete account of other common surprises.\n\nAs that says near the end, \"there are no easy answers.\"  Still, don't be unduly\nwary of floating point!  The errors in Python float operations are inherited\nfrom the floating-point hardware, and on most machines are on the order of no\nmore than 1 part in 2\\*\\*53 per operation.  That's more than adequate for most\ntasks, but you do need to keep in mind that it's not decimal arithmetic and\nthat every float operation can suffer a new rounding error.\n\nWhile pathological cases do exist, for most casual use of floating-point\narithmetic you'll see the result you expect in the end if you simply round the\ndisplay of your final results to the number of decimal digits you expect.\n:func:`str` usually suffices, and for finer control see the :meth:`str.format`\nmethod's format specifiers in :ref:`formatstrings`.\n\nFor use cases which require exact decimal representation, try using the\n:mod:`decimal` module which implements decimal arithmetic suitable for\naccounting applications and high-precision applications.\n\nAnother form of exact arithmetic is supported by the :mod:`fractions` module\nwhich implements arithmetic based on rational numbers (so the numbers like\n1/3 can be represented exactly).\n\nIf you are a heavy user of floating-point operations you should take a look\nat the NumPy package and many other packages for mathematical and\nstatistical operations supplied by the SciPy project. See <https://scipy.org>.\n\nPython provides tools that may help on those rare occasions when you really\n*do* want to know the exact value of a float.  The\n:meth:`float.as_integer_ratio` method expresses the value of a float as a\nfraction:",
    "example_code": "x = 3.14159\n\nx.as_integer_ratio()\n\n(3537115888337719, 1125899906842624)"
  },
  {
    "unit_id": "floatingpoint.rst-13",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Since the ratio is exact, it can be used to losslessly recreate the\noriginal value:",
    "example_code": "x == 3537115888337719 / 1125899906842624\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-14",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "The :meth:`float.hex` method expresses a float in hexadecimal (base\n16), again giving the exact value stored by your computer:",
    "example_code": "x.hex()\n\n'0x1.921f9f01b866ep+1'"
  },
  {
    "unit_id": "floatingpoint.rst-15",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "This precise hexadecimal representation can be used to reconstruct\nthe float value exactly:",
    "example_code": "x == float.fromhex('0x1.921f9f01b866ep+1')\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-16",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "Since the representation is exact, it is useful for reliably porting values\nacross different versions of Python (platform independence) and exchanging\ndata with other languages that support the same format (such as Java and C99).\n\nAnother helpful tool is the :func:`sum` function which helps mitigate\nloss-of-precision during summation.  It uses extended precision for\nintermediate rounding steps as values are added onto a running total.\nThat can make a difference in overall accuracy so that the errors do not\naccumulate to the point where they affect the final total:",
    "example_code": "0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n\nFalse\n\nsum([0.1] * 10) == 1.0\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-17",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [],
    "concept_text": "The :func:`math.fsum` goes further and tracks all of the \"lost digits\"\nas values are added onto a running total so that the result has only a\nsingle rounding.  This is slower than :func:`sum` but will be more\naccurate in uncommon cases where large magnitude inputs mostly cancel\neach other out leaving a final sum near zero:",
    "example_code": "arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n\n       -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n\nfloat(sum(map(Fraction, arr)))   # Exact summation with single rounding\n\n8.042173697819788e-13\n\nmath.fsum(arr)                   # Single rounding\n\n8.042173697819788e-13\n\nsum(arr)                         # Multiple roundings in extended precision\n\n8.042178034628478e-13\n\ntotal = 0.0\n\nfor x in arr:\n\n    total += x                   # Multiple roundings in standard precision\n\n...\n\ntotal                            # Straight addition has no correct digits!\n\n-0.0051575902860057365"
  },
  {
    "unit_id": "floatingpoint.rst-18",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "This section explains the \"0.1\" example in detail, and shows how you can perform\nan exact analysis of cases like this yourself.  Basic familiarity with binary\nfloating-point representation is assumed.\n\n:dfn:`Representation error` refers to the fact that some (most, actually)\ndecimal fractions cannot be represented exactly as binary (base 2) fractions.\nThis is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many\nothers) often won't display the exact decimal number you expect.\n\nWhy is that?  1/10 is not exactly representable as a binary fraction.  Since at\nleast 2000, almost all machines use IEEE 754 binary floating-point arithmetic,\nand almost all platforms map Python floats to IEEE 754 binary64 \"double\nprecision\" values.  IEEE 754 binary64 values contain 53 bits of precision, so\non input the computer strives to convert 0.1 to the closest fraction it can of\nthe form *J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.\nRewriting",
    "example_code": "1 / 10 ~= J / (2**N)"
  },
  {
    "unit_id": "floatingpoint.rst-19",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "",
    "example_code": "J ~= 2**N / 10"
  },
  {
    "unit_id": "floatingpoint.rst-20",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< 2**53``),\nthe best value for *N* is 56:",
    "example_code": "2**52 <=  2**56 // 10  < 2**53\n\nTrue"
  },
  {
    "unit_id": "floatingpoint.rst-21",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  The\nbest possible value for *J* is then that quotient rounded:",
    "example_code": "q, r = divmod(2**56, 10)\n\nr\n\n6"
  },
  {
    "unit_id": "floatingpoint.rst-22",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "Since the remainder is more than half of 10, the best approximation is obtained\nby rounding up:",
    "example_code": "q+1\n\n7205759403792794"
  },
  {
    "unit_id": "floatingpoint.rst-23",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "Therefore the best possible approximation to 1/10 in IEEE 754 double precision",
    "example_code": "7205759403792794 / 2 ** 56"
  },
  {
    "unit_id": "floatingpoint.rst-24",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "",
    "example_code": "3602879701896397 / 2 ** 55"
  },
  {
    "unit_id": "floatingpoint.rst-25",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "Note that since we rounded up, this is actually a little bit larger than 1/10;\nif we had not rounded up, the quotient would have been a little bit smaller than\n1/10.  But in no case can it be *exactly* 1/10!\n\nSo the computer never \"sees\" 1/10:  what it sees is the exact fraction given\nabove, the best IEEE 754 double approximation it can get:",
    "example_code": "0.1 * 2 ** 55\n\n3602879701896397.0"
  },
  {
    "unit_id": "floatingpoint.rst-26",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "If we multiply that fraction by 10\\*\\*55, we can see the value out to\n55 decimal digits:",
    "example_code": "3602879701896397 * 10 ** 55 // 2 ** 55\n\n1000000000000000055511151231257827021181583404541015625"
  },
  {
    "unit_id": "floatingpoint.rst-27",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "meaning that the exact number stored in the computer is equal to\nthe decimal value 0.1000000000000000055511151231257827021181583404541015625.\nInstead of displaying the full decimal value, many languages (including\nolder versions of Python), round the result to 17 significant digits:",
    "example_code": "format(0.1, '.17f')\n\n'0.10000000000000001'"
  },
  {
    "unit_id": "floatingpoint.rst-28",
    "source_file": "floatingpoint.rst",
    "topic_hierarchy": [
      "Representation Error"
    ],
    "concept_text": "The :mod:`fractions` and :mod:`decimal` modules make these calculations\neasy:",
    "example_code": "from decimal import Decimal\n\nfrom fractions import Fraction\n\n\nFraction.from_float(0.1)\n\nFraction(3602879701896397, 36028797018963968)\n\n\n(0.1).as_integer_ratio()\n\n(3602879701896397, 36028797018963968)\n\n\nDecimal.from_float(0.1)\n\nDecimal('0.1000000000000000055511151231257827021181583404541015625')\n\n\nformat(Decimal.from_float(0.1), '.17')\n\n'0.10000000000000001'"
  },
  {
    "unit_id": "appendix.rst-0",
    "source_file": "appendix.rst",
    "topic_hierarchy": [
      "Interactive Mode",
      "Executable Python Scripts"
    ],
    "concept_text": "On BSD'ish Unix systems, Python scripts can be made directly executable, like",
    "example_code": ""
  },
  {
    "unit_id": "appendix.rst-1",
    "source_file": "appendix.rst",
    "topic_hierarchy": [
      "Interactive Mode",
      "The Interactive Startup File"
    ],
    "concept_text": "When you use Python interactively, it is frequently handy to have some standard\ncommands executed every time the interpreter is started.  You can do this by\nsetting an environment variable named :envvar:`PYTHONSTARTUP` to the name of a\nfile containing your start-up commands.  This is similar to the :file:`.profile`\nfeature of the Unix shells.\n\nThis file is only read in interactive sessions, not when Python reads commands\nfrom a script, and not when :file:`/dev/tty` is given as the explicit source of\ncommands (which otherwise behaves like an interactive session).  It is executed\nin the same namespace where interactive commands are executed, so that objects\nthat it defines or imports can be used without qualification in the interactive\nsession. You can also change the prompts ``sys.ps1`` and ``sys.ps2`` in this\nfile.\n\nIf you want to read an additional start-up file from the current directory, you\ncan program this in the global start-up file using code like ``if\nos.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())``.\nIf you want to use the startup file in a script, you must do this explicitly",
    "example_code": "import os\n\nfilename = os.environ.get('PYTHONSTARTUP')\n\nif filename and os.path.isfile(filename):\n\n    with open(filename) as fobj:\n\n        startup_file = fobj.read()\n\n    exec(startup_file)"
  },
  {
    "unit_id": "appendix.rst-2",
    "source_file": "appendix.rst",
    "topic_hierarchy": [
      "Interactive Mode",
      "The Customization Modules"
    ],
    "concept_text": "Python provides two hooks to let you customize it: :index:`sitecustomize` and\n:index:`usercustomize`.  To see how it works, you need first to find the location",
    "example_code": "import site\n\nsite.getusersitepackages()\n\n'/home/user/.local/lib/python3.x/site-packages'"
  }
]